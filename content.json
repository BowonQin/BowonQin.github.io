{"meta":{"title":"Bowon Qin","subtitle":"Bowon Qin 的Blog","description":"java后端相关技术栈","author":"Bowon Qin","url":"https://bowonqin.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-12-16T06:00:51.035Z","comments":true,"path":"404.html","permalink":"https://bowonqin.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-12-16T06:00:51.250Z","comments":true,"path":"about/index.html","permalink":"https://bowonqin.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-12-16T06:00:51.251Z","comments":true,"path":"archives/index.html","permalink":"https://bowonqin.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-24T16:00:00.000Z","updated":"2021-12-16T11:07:27.488Z","comments":true,"path":"categories/index.html","permalink":"https://bowonqin.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-12-16T06:00:51.255Z","comments":true,"path":"friends/index.html","permalink":"https://bowonqin.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-12-16T06:00:51.257Z","comments":true,"path":"resource/index.html","permalink":"https://bowonqin.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-12-16T06:00:51.257Z","comments":true,"path":"tags/index.html","permalink":"https://bowonqin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis(基础)","slug":"mabatis/Mybatis(基础)","date":"2021-12-16T16:00:00.000Z","updated":"2021-12-18T14:54:41.574Z","comments":true,"path":"posts/1111222.html","link":"","permalink":"https://bowonqin.github.io/posts/1111222.html","excerpt":"","text":"Mybatis相关概念ORM(对象关系数据库映射) ORM全称Object/Relation Mapping：表示对象-关系映射的缩写 ORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层SQL操作。ORM框架实现的效果：把对持久化对象的保存、修改、删除等操作，转换为对数据库的操作 Mybatis简介 MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO （Plain Old Java Objects,普通老式Java对 象）为数据库中的记录。 Mybatis历史 原是apache的一个开源项目iBatis, 2010年6月这个项目由apache software foundation 迁移到了google code，随着开发团队转投Google Code旗下，ibatis3.x正式更名为Mybatis ，代码于2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects(DAO) Mybatis优势 Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。 Mybatis基本应用 Mybatis官网地址：http://www.mybatis.org/mybatis-3/ 快速入门开发步骤： 添加Mybatis坐标 创建user数据表 编写User实体类 编写映射文件UserMapper.xml 编写核心文件SqlMapperConfig.xml 编写测试类 环境搭建1）导入MyBatis的坐标和其他相关坐标 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--mybatis坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--单元测试坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建数据库表 3）编写User实体 public class User { private Integer id; private String username; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + '}'; } } 编写UserMapper映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"user\"&gt; &lt;!-- namespace命名空间，与id组成sql的唯一标识 resultType: 返回值类型 --&gt; &lt;select id=\"findAll\" resultType=\"com.qxd.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 编写Mybatis核心配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写测试类 public class MybatisTest { @Test public void test1() throws IOException { // 加载核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); //获得sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得sqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句 List&lt;User&gt; users = sqlSession.selectList(\"user.findAll\"); // 打印结果 for (User : users) { System.out.println(user); } // 释放资源 sqlSession.close(); } } 打印结果为： User{id=1, username='qqq'} User{id=2, username='zhangsan'} User{id=4, username='null'} Mybatis的增删改查操作Mybatis的插入数据操作 编写UserMapper映射文件 &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"com.qxd.pojo.User\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 编写测试类 @Test public void test2() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(3); user.setUsername(\"sd\"); sqlSession.insert(\"user.saveUser\",user); sqlSession.commit(); sqlSession.close(); } 插入操作注意问题 插入语句使用insert标签 在映射文件中使用parameterType属性指定要插入的数据类型 Sql语句中使用#{实体属性名}方式引用实体中的属性值 插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); 插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() Mybatis的修改数据操作 编写UserMapper映射文件 &lt;!-- 修改--&gt; &lt;mapper&gt; &lt;update id=\"update\" parameterType=\"com.qxd.pojo.User\"&gt; update user set username=#{username} where id = #{id} &lt;/update&gt; &lt;/mapper&gt; 编写测试类 @Test public void test3() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(1); user.setUsername(\"xxx\"); int update = sqlSession.update(\"user.update\", user); System.out.println(update); sqlSession.commit(); sqlSession.close(); } 修改操作注意问题 修改语句使用update标签 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); Mybatis的删除数据操作 编写UserMapper映射文件 &lt;mapper&gt; &lt;!-- 删除--&gt; &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 编写测试类 // 删除 public void test4() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int delete = sqlSession.delete(\"user.delete\", 5); System.out.println(delete); sqlSession.commit(); sqlSession.close(); } 删除操作注意问题 删除语句使用delete标签 Sql语句中使用#{任意字符串}方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); Mybatis的映射文件概述 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--映射文件DTD约束头--&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!--mapper为根标签--&gt; &lt;mapper namespace=\"user\"&gt; &lt;!-- namespace命名空间，与id组成sql的唯一标识 resultType: 返回值类型 --&gt; &lt;select id=\"findAll\" resultType=\"com.qxd.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; Mybatis常用映射文件解析1） environments标签 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--当前运行环境--&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据源配置的基本餐宿--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mapper标签 该标签的作用是加载映射的，加载方式有如下几种： &lt;!--使用相对于类路径的资源引用，例如：--&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;!--使用完全限定资源定位符（URL），例如： --&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;!--使用映射器接口实现类的完全限定类名，例如： --&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!--将包内的映射器接口实现全部注册为映射器，例如：--&gt; &lt;mapper name=\"org.mybatis.builder\"/&gt; Mybatis相应API SqlSession工厂构建器SqlSessionFactoryBuilder 常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 SqlSession工厂对象SqlSessionFactory SqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： // 默认为false,需要手动开启事务 SqlSession sqlSession = sqlSessionFactory.openSession(); // 手动提交事务 sqlSession.commit() // -----------------------------------------------------------------------------// // 自动开启事务，无需手动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); SqlSession会话对象 SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有 &lt;T&gt; T selectOne(String statement, Object parameter); &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter); int insert(String statement, Object parameter); int update(String statement, Object parameter); int delete(String statement, Object parameter); 操作事务的方法主要有： void commit() void rollback() Mybatis的Dao层实现传统开发方式 编写UserDao接口 public interface IUserDao { // 查询所有用户 public List&lt;User&gt; findAll() throws IOException; } 编写UserDaoImpl实现 public class UserDaoImpl implements IUserDao { @Override public List&lt;User&gt; findAll() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; users = sqlSession.selectList(\"user.findAll\"); sqlSession.close(); return users; } } 测试传统方式 @Test public void test5() throws IOException { IUserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); for (User user : all) { System.out.println(user); } } 代理开发方式 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范：、 1） Mapper.xml中的namespace与mapper接口的全限类名相同。 2） Mapper接口方法名和Mapper.xm中定义的每个statemen的id相同 3） Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4） Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 测试代理方法 @Test public void test6() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); IUserDao userDao = sqlSession.getMapper(IUserDao.class); List&lt;User&gt; all = userDao.findAll(); for (User user : all) { System.out.println(user); } sqlSession.close(); } Mybatis配置文件深入核心配置文件environments标签&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--当前运行环境--&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据源配置的基本餐宿--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mapper标签该标签的作用是加载映射的，加载方式有如下几种： &lt;!--使用相对于类路径的资源引用，例如：--&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;!--使用完全限定资源定位符（URL），例如： --&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;!--使用映射器接口实现类的完全限定类名，例如： --&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!--将包内的映射器接口实现全部注册为映射器，例如：--&gt; &lt;mapper name=\"org.mybatis.builder\"/&gt; Properties标签实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 加载外部properties --&gt; &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; typeAliases标签类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"com.qxd.pojo.User\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 配置typeAliases，为com.lagou.domain.User定义别名为user &lt;typeAliases&gt; &lt;!-- 单独实体起别名 --&gt; &lt;typeAlias type=\"com.qxd.pojo.User\" alias=\"user\"&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"user\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 批量起别名:该包下所有类的本身的类名：别名不区分大小写 &lt;!-- 给实体类的全限定类名起别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量起别名：该包下所有类的本身的类名：别名不区分大小写--&gt; &lt;package name=\"com.qxd.pojo\"/&gt; &lt;/typeAliases&gt; 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean …… …… 映射配置文件mapper.xml动态sql语句动态 SQL 之 我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 &lt;!-- 多条件组合查询--&gt; &lt;select id=\"findByCondition\" resultType=\"user\" parameterType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"id != null\"&gt; and id = #{id} &lt;/if&gt; &lt;if test=\"username !=null\"&gt; and username = #{username} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 动态 SQL 之 循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 &lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=\"array\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; foreach标签的属性含义如下： 标签用于遍历集合，它的属性： collection: 代表要遍历的集合元素，注意编写时不要写#{}。 open：代表语句的开始部分。 close：代表结束部分。 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 SQL片段抽取 Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 &lt;!-- 抽取mysql片段--&gt; &lt;sql id=\"selectUser\"&gt; select * from User &lt;/sql&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;/select&gt; Mybatis复杂映射开发一对一查询一对一查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询语句对应的sql语句： select * from orders o,user u where o.uid=u.id; 查询的结果如下： 创建Order和User实体public class Order { private Integer id; private String ordertime; private Double total; //代表当前订单从属于哪一个客户 private User user; get() set() } public class User { private Integer id; private String username; private String password; private String birthday; get() set() } 创建IUserMapper接口public interface IUserMapper { // 查询订单的同时还查询该订单所属的用户 public List&lt;Order&gt; findOrderAndUser(); } 配置IUserMapper.xml&lt;mapper namespace=\"com.qxd.mapper.IUserMapper\"&gt; &lt;!--resultMap:手动配置实体属性和表字段的映射关系 --&gt; &lt;resultMap id=\"orderMap\" type=\"com.qxd.pojo.Order\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"orderTime\" column=\"orderTime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"com.qxd.pojo.User\"&gt; &lt;result property=\"id\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findOrderAndUser\" resultMap=\"orderMap\"&gt; select * from orders o,user u where o.uid=u.id; &lt;/select&gt; &lt;/mapper&gt; 其中，sqlMapperConfig.xml导包的时候可以做如下配置 &lt;mappers&gt; &lt;!--同包同名--&gt; &lt;package name=\"com.qxd.mapper\"/&gt; &lt;/mappers&gt; 其中，使用package标签导包的时候要保证mapper.xml与mapper接口同包同名才能成功。 一对多查询模型一对多查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询语句对应的sql语句： select *,o.id oid from user u left join orders o on u.id=o.uid; 查询的结果如下： 修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); } public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; } 创建IUserMapper接口public interface IUserMapper { // 查询所有用户拥有的订单 public List&lt;User&gt; findAll(); } 配置IUserMapper.xml&lt;mapper&gt; &lt;resultMap id=\"userMap\" type=\"com.qxd.pojo.User\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!--集合类型+泛型--&gt; &lt;collection property=\"orderList\" ofType=\"com.qxd.pojo.Order\"&gt; &lt;result property=\"id\" column=\"oid\"&gt;&lt;/result&gt; &lt;result property=\"orderTime\" column=\"orderTime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select *,o.id oid from user u left join orders o on u.id=o.uid; &lt;/select&gt; &lt;/mapper&gt; 多对多查询多对多查询模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询语句对应的sql语句： SELECT u.*, r.*, r.id rid FROM USER u LEFT JOIN sys_user_role ur ON u.id = ur.userid LEFT JOIN sys_role r ON ur.roleid = r.id; 查询结果如下 创建Role实体，修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); // 表示用户当前的角色 private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); } public class Role { private Integer id; private String roleName; private String roleDesc; } 添加UserMapper接口方法// 查询所有用户拥有的角色 public List&lt;User&gt; findAllUserAndRole(); 配置IUserMapper.xml&lt;mapper&gt; &lt;resultMap id=\"userRoleMap\" type=\"user\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;collection property=\"roleList\" ofType=\"Role\"&gt; &lt;result property=\"id\" column=\"rid\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"roleDesc\"&gt;&lt;/result&gt; &lt;result property=\"roleName\" column=\"roleName\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAllUserAndRole\" resultMap=\"userRoleMap\"&gt; SELECT u.*, r.*, r.id rid FROM USER u LEFT JOIN sys_user_role ur ON u.id = ur.userid LEFT JOIN sys_role r ON ur.roleid = r.id; &lt;/select&gt; &lt;/mapper&gt; 知识小结一对一配置： 使用做配置 一对多配置： 使用+做配置 多对多配置： 使用+做配置 Mybatis注解开发MyBatis常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 Mybatis增删改查我们完成简单的user表的增删改查的操作 private IUserMapper userMapper; @BeforeEach public void before() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(IUserMapper.class); } @Test public void addUserTest() throws IOException { User user = new User(); user.setId(6); user.setUsername(\"qqq\"); user.setBirthday(\"2021-1-1\"); user.setPassword(\"123321\"); userMapper.addUser(user); } @Test public void selectUserTest(){ List&lt;User&gt; users = userMapper.selectUsers(); for (User user : users) { System.out.println(user); } } @Test public void udpateUserTest(){ User user = new User(); user.setId(6); user.setUsername(\"xxx\"); user.setBirthday(\"2021-11-1\"); user.setPassword(\"1233221\"); userMapper.updateUser(user); } @Test public void deleteUserTest(){ userMapper.delete(6); } MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 一对一查询一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句select * from orders; select * from user where id=查询出订单的uid; 创建Order和User实体public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; get set toString() } public class User { private Integer id; private String username; private String password; private String birthday; get set toString() } 创建OrderMapper接口public interface IOrderMapper { public List&lt;Order&gt;findAll(); } 使用注解配置Mapperpublic interface IOrderMapper { @Select(\"select * from orders\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"orderTime\",column = \"ordertime\"), @Result(property = \"total\",column = \"total\"), @Result(property = \"user\",column = \"uid\",javaType = User.class,one = @One(select = \"com.qxd.mapper.IUserMapper.findById\")), }) public List&lt;Order&gt;findAll(); } public interface IUserMapper{ @Select(\"select * from user where id=#{id}\") public User findById(Integer id); } 测试结果 @Test public void testSelectOrderAndUser() { List&lt;Order&gt; all = orderMapper.findAll(); for (Order order : all) { System.out.println(order); } } // 打印结果 Order{id=1, orderTime=2019-12-12, total=3000.0, user=User{id=1, username='lucy', password='123', birthday='2019-12-12} Order{id=2, orderTime=2019-12-12, total=4000.0, user=User{id=1, username='lucy', password='123', birthday='2019-12-12} Order{id=3, orderTime=2019-12-12, total=5000.0, user=User{id=2, username='tom', password='123', birthday='2019-12-12} 一对多查询一对多查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询的语句对应的sql语句： select * from user; select * from orders where uid=查询出用户的id; 修改Order和User实体public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; get set toString() } public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); get set toString() } 创建UserMapper接口public interface IUserMapper { public List&lt;User&gt; findOrderAndUserByAnnotation(); } 使用注解配置Mapperpublic interface IUserMapper { // 查询订单的同时还查询该订单所属的用户 @Select(\"select * from user\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"orderList\",column = \"id\",javaType = List.class,many = @Many(select = \"com.qxd.mapper.IOrderMapper.findByUid\")), }) public List&lt;User&gt; findOrderAndUserByAnnotation(); } public interface IOrderMapper { @Select(\"select * from orders where uid=#{uid}\") public Order findByUid(Integer uid); } 测试结果 @Test public void testSelectUserAndOrder(){ List&lt;User&gt; orderAndUserByAnnotation = userMapper.findOrderAndUserByAnnotation(); for (User user : orderAndUserByAnnotation) { System.out.println(user); } } // 打印结果 User{id=1, username='lucy', password='123', birthday='2019-12-12', orderList=[Order{id=1, orderTime='2019-12-12', total=3000.0}, Order{id=2, orderTime='2019-12-12', total=4000.0}]} User{id=2, username='tom', password='123', birthday='2019-12-12', orderList=[Order{id=3, orderTime='2019-12-12', total=5000.0}]} User{id=3, username='jack', password='123', birthday='2017-1-1', orderList=[]} User{id=5, username='qqq', password='123321', birthday='2021-1-1', orderList=[]} 多对多查询多对多查询模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询语句select * from user; select * from role r, sys_user_role ur where r.id=ur.roleid and ur.userid=用户的id 创建Role实体，修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 // private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); // 表示用户当前的角色 private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); get set toString } public class Role { private Integer id; private String roleName; private String roleDesc; get set toString } 添加UserMapper接口方法public interface IUserMapper { public List&lt;User&gt; findOrderAndUserByAnnotation(); } 使用注解配置Mapperpublic interface IUserMapper{ @Select(\"select * from user\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"roleList\",column = \"id\",javaType = List.class,many = @Many(select = \"com.qxd.mapper.IRoleMapper.findRoleByUid\")), }) public List&lt;User&gt; findUserAndRoleByAnnotation(); } public interface IRoleMapper{ @Select(\"select * from sys_role r, sys_user_role ur where r.id=ur.roleid and ur.userid=#{uid}\") public Role findRoleByUid(Integer uid); } 测试结果 @Test public void testUserAndRole(){ List&lt;User&gt; userAndRoleByAnnotation = userMapper.findUserAndRoleByAnnotation(); for (User user : userAndRoleByAnnotation) { System.out.println(user); } } // 打印结果 User{id=1, username='lucy', password='123', birthday='2019-12-12', roleList=[Role{id=1, roleName='CTO', roleDesc='CTO'}, Role{id=2, roleName='CEO', roleDesc='CEO'}]} User{id=2, username='tom', password='123', birthday='2019-12-12', roleList=[Role{id=1, roleName='CTO', roleDesc='CTO'}, Role{id=2, roleName='CEO', roleDesc='CEO'}]} User{id=3, username='jack', password='123', birthday='2017-1-1', roleList=[]} User{id=5, username='qqq', password='123321', birthday='2021-1-1', roleList=[]}","categories":[{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"}],"author":"qxd"},{"title":"牛客高频面试题","slug":"常见面试题总结/牛客100","date":"2021-12-16T16:00:00.000Z","updated":"2021-12-17T14:20:56.882Z","comments":true,"path":"posts/niuke100.html","link":"","permalink":"https://bowonqin.github.io/posts/niuke100.html","excerpt":"","text":"字符串搜索-BF和RK 给定两个字符串A、B，判断B在A中是否存在，存在返回A中的下标，不存在返回-1 例如： A：ABCABCABCCCAAA ​ B: BCCCA 返回值 6 java中的String.indexOf()方法可以实现 BF暴力算法逐字符地进行匹配（比较A[i]和B[j]）,如果当前字符匹配成功（A[i] == B[j]），就匹配下一个字符（++i,++j），如果失配，i回溯，j置为0（i = i-j+1,j=0） 时间复杂度为O(n*m)，与主串和模式串的长度正相关 // pat匹配串 // txt原串 int search(String pat, String txt) { if (pat == null || txt == null) { return -1; } int M = pat.length(); int N = txt.length(); for (int i = 0; i &lt; N - M; i++) { int j; for (j = 0; j &lt; M; j++) { if (pat.charAt(j) != txt.charAt(i + j)) { break; } } // pat全部匹配了 if (j == M) return i; } return -1; } RK算法：hash算法基于BF进行优化，将A字符按顺序和B串的长度进行截取。两者hash值比对。时间复杂度为O(m*n),hash算法参与的字符位数（模式串的长度）、及主串长度正相关 优化：hash算法：按26位进制取和，abc=1+2+3=6 则每一个字符串的hash值是前一个子串的hash值减去子串最小下标值、加上本串的最大下标值 bcd=abc-a+d=6-1+4=9 时间复杂度变为：O（N）,只与主串长度相关，但是hash冲突极端情况下会退化为BF","categories":[{"name":"面试篇","slug":"面试篇","permalink":"https://bowonqin.github.io/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://bowonqin.github.io/tags/%E7%89%9B%E5%AE%A2/"},{"name":"面试","slug":"面试","permalink":"https://bowonqin.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":"qxd"},{"title":"开源项目eladmin解析（一）","slug":"开源项目/开源项目eladmin(1)","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-17T00:45:00.520Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://bowonqin.github.io/posts/0.html","excerpt":"","text":"前言 作为初学者该如何学习开源项目呢，这里以githu/gitee上一个非常流行的后台管理系统eladmin为例。这里学习的目的是总结和归纳如何对项目进行分模块剖析，以及将拆分的模块快速的应用于新项目中。这里是eladmin的相关链接地址 github 地址 gitee 地址 开发文档 地址 技术栈分析 后端：Springboot、Springboot Jpa、JWT、SpringSecurity、Mysql、Redis 前端：Vue、Element-UI IDE及和可视化工具 IDEA Navicat Another Redis Desktop Manager(Redis可视化工具) （AnotherRedisDesktopManager 发行版 - Gitee.com） 主要特性 使用最新技术栈，社区资源丰富。 高效率开发，代码生成器可一键生成前后端代码 支持数据字典，可方便地对一些状态进行管理 支持接口限流，避免恶意请求导致服务层压力过大 支持接口级别的功能权限与数据权限，可自定义操作 自定义权限注解与匿名接口注解，可快速对接口拦截与放行 对一些常用地前端组件封装：表格数据请求、数据字典等 前后端统一异常拦截处理，统一输出异常，避免繁琐的判断 支持在线用户管理与服务器性能监控，支持限制单用户登录 支持运维管理，可方便地对远程服务器的应用进行部署与管理 主要功能 用户管理：提供用户的相关配置，新增用户后，默认密码为123456 角色管理：对权限与菜单进行分配，可根据部门设置角色的数据权限 菜单管理：已实现菜单动态路由，后端可配置化，支持多级菜单 部门管理：可配置系统组织架构，树形表格展示 岗位管理：配置各个部门的职位 字典管理：可维护常用一些固定的数据，如：状态，性别等 系统日志：记录用户操作日志与异常日志，方便开发人员定位排错 SQL监控：采用druid 监控数据库访问性能，默认用户名admin，密码123456 定时任务：整合Quartz做定时任务，加入任务日志，任务运行情况一目了然 代码生成：高灵活度生成前后端代码，减少大量重复的工作任务 邮件工具：配合富文本，发送html格式的邮件七牛云存储：可同步七牛云存储的数据到系统，无需登录七牛云直接操作云数据 支付宝支付：整合了支付宝支付并且提供了测试账号，可自行测试 服务监控：监控服务器的负载情况 运维管理：一键部署你的应用 项目结构 eladmin-common 为系统的公共模块，各种工具类，公共配置存在该模块 eladmin-system 为系统核心模块也是项目入口模块，也是最终需要打包部署的模块 eladmin-logging 为系统的日志模块，其他模块如果需要记录日志需要引入该模块 eladmin-tools 为第三方工具模块，包含：图床、邮件、云存储、本地存储、支付宝 eladmin-generator 为系统的代码生成模块，代码生成的模板在 system 模块中 详细结构- eladmin-common 公共模块 - annotation 为系统自定义注解 - aspect 自定义注解的切面 - base 提供了Entity、DTO基类和mapstruct的通用mapper - config 自定义权限实现、redis配置、swagger配置、Rsa配置等 - exception 项目统一异常的处理 - utils 系统通用工具类 - eladmin-system 系统核心模块（系统启动入口） - config 配置跨域与静态资源，与数据权限 - thread 线程池相关 - modules 系统相关模块(登录授权、系统监控、定时任务、运维管理等) - eladmin-logging 系统日志模块 - eladmin-tools 系统第三方工具模块 - eladmin-generator 系统代码生成模块","categories":[{"name":"开源项目篇","slug":"开源项目篇","permalink":"https://bowonqin.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://bowonqin.github.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"eladmin","slug":"eladmin","permalink":"https://bowonqin.github.io/tags/eladmin/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"}],"author":"qxd"},{"title":"Springboot+SpringSecurity+Vue后台管理系统","slug":"实战项目/Springboot+Vue后台管理系统(Vue)","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-17T06:31:45.766Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://bowonqin.github.io/posts/2.html","excerpt":"","text":"安装Vue环境，新建Vue项目 查看nodejs和npm版本信息 安装vue环境 # 安装淘宝npm npm install -g cnpm --registry=https://registry.npm.taobao.org # 安装vue-cli依赖包 cnpm install -g vue-cli # 打开vue可视化管理工具vue ui vue ui 是一个可视化管理工具，可以运行项目、打包项目、检查等操作 按步骤下一步即可 安装Element-uicnpm install element-ui --save 安装成功后，打开项目src中的main.js，引入element-ui的依赖 import Element from \"element-ui\" import \"element-ui/lib/theme-chalk/index.css\" Vue.use(Element); 安装axios、qs、mockjs axios: 一个基于promise的HTTP库，类似ajax 安装： cnpm install axios --save 引入依赖 import axios from 'axios' Vue.prototype.$axios = axios qs: 查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，也可以将一个查询字符串解析成一个object 安装： cnpm install qs --save mockjs: 随机数据工具库 安装： cnpm install axios --save-dev 页面路由 传统项目开发，后端通过链接达到控制器再到页面渲染 前后端分离：先访问页面，然后异步加载数据渲染。路由管理的组件为Router Router: 建立起url和页面之间的映射关系 import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home.vue' Vue.use(VueRouter) const routes = [{ path: '/', name: 'Home', component: Home }, { path: '/login/', name: 'Login', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =&gt; import( /* webpackChunkName: \"about\" */ '../views/Login.vue') } ] const router = new VueRouter({ routes, mode: 'history' //去除#号 }) export default router 通过访问 http://localhost:8081/ 可以访问到Home.vue中的内容，这种先import的模式是及急加载模式。 通过访问 http://localhost:8081/login 可以访问到Login.vue中的内容，这种用到组件再import模式是懒加载的模式。 登录页面的开发开发流程： 浏览器打开登录页面 动态加载登录验证码，前后端分离项目不用session进行交互，禁用session。在后端生成验证码同时生成随机码，随机码作为key，验证码作为value存放在redis中，然后把随机码和验证码的Base64字符串发送到前端 前端提交用户名、密码、验证码和随机码 后台验证验证码是否匹配以及密码是否正确 mock.js的设计 const Mock = require(\"mockjs\"); const Random = Mock.Random let Result = { code: 200, msg: '操作成功', data: null } Mock.mock(\"/captcha\", 'get', () =&gt; { Result.data ={ token: Random.string(32), captchaImg: Random.dataImage('100x40','p7n5w') } return Result }) Mock.mock(\"/login\",'post',()=&gt;{ // 无法在header中传入数据 }) 模拟后台发送随机码和Base64编码的验证码 login.vue页面的设计 &lt;template&gt; &lt;el-row type=\"flex\" class=\"row-bg\" justify=\"center\"&gt; &lt;el-col :xl=\"6\" :lg=\"7\"&gt; &lt;h2&gt;欢迎来到VueAdmin管理系统&lt;/h2&gt; &lt;el-image :src=\"require('@/assets/logo.png')\" style=\"height: 180px; width: 180px\" &gt;&lt;/el-image&gt; &lt;/el-col&gt; &lt;!-- 分割线 --&gt; &lt;el-col :span=\"1\"&gt; &lt;el-divider direction=\"vertical\"&gt;&lt;/el-divider&gt; &lt;/el-col&gt; &lt;el-col :xl=\"6\" :lg=\"7\"&gt; &lt;el-form :model=\"LoginForm\" :rules=\"rules\" ref=\"LoginForm\" label-width=\"100px\" class=\"demo-LoginForm\" &gt; &lt;el-form-item label=\"用户名\" prop=\"username\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.username\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"password\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.password\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"验证码\" prop=\"code\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.code\" style=\"width: 172px; float: left\" maxlength=\"5\" &gt;&lt;/el-input&gt; &lt;el-image :src=\"captchaImg\" class=\"captchaImg\" &gt;&lt;/el-image&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" @click=\"submitForm('LoginForm')\" &gt;立即创建&lt;/el-button &gt; &lt;el-button @click=\"resetForm('LoginForm')\"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { LoginForm: { username: \"\", password: \"\", code: \"\", token: \"\", }, rules: { username: [ { required: true, message: \"请输入用户名\", trigger: \"blur\" }, ], password: [{ required: true, message: \"请输入密码\", trigger: \"blur\" }], code: [ { required: true, message: \"请输入验证码\", trigger: \"blur\" }, { min: 5, max: 5, message: \"长度为5个字符\", trigger: \"blur\" }, ], }, captchaImg: null, }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { this.$axios.post(\"/login\", this.LoginForm).then((res) =&gt; { const jwt = res.headers['authorization'] this.$store.commit('SET_TOKEN', jwt) this.$router.push(\"/index\") }); } else { console.log(\"error submit!!\"); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); }, getCaptcha() { this.$axios.get(\"/captcha\").then((res) =&gt; { console.log(\"/captcha\"); console.log(res); this.LoginForm.token = res.data.data.token; this.captchaImg = res.data.data.captchaImg; }); }, }, created() { this.getCaptcha(); }, }; &lt;/script&gt; &lt;style scoped&gt; .el-row { background-color: #fafafa; height: 100vh; display: flex; align-items: center; text-align: center; justify-content: center; } .el-divider { height: 200px; } .captchaImg { float: left; margin-left: 8px; border-radius: 4px; } &lt;/style&gt;","categories":[{"name":"实战项目篇","slug":"实战项目篇","permalink":"https://bowonqin.github.io/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"实战项目","slug":"实战项目","permalink":"https://bowonqin.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"},{"name":"Vue","slug":"Vue","permalink":"https://bowonqin.github.io/tags/Vue/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://bowonqin.github.io/tags/SpringSecurity/"}],"author":"qxd"},{"title":"开源项目eladmin解析（二）","slug":"开源项目/开源项目eladmin(2)","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-17T00:45:04.970Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://bowonqin.github.io/posts/1.html","excerpt":"","text":"登录功能登录流程","categories":[{"name":"开源项目篇","slug":"开源项目篇","permalink":"https://bowonqin.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://bowonqin.github.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"eladmin","slug":"eladmin","permalink":"https://bowonqin.github.io/tags/eladmin/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"}],"author":"qxd"}],"categories":[{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"},{"name":"面试篇","slug":"面试篇","permalink":"https://bowonqin.github.io/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"name":"开源项目篇","slug":"开源项目篇","permalink":"https://bowonqin.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%AF%87/"},{"name":"实战项目篇","slug":"实战项目篇","permalink":"https://bowonqin.github.io/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"},{"name":"牛客","slug":"牛客","permalink":"https://bowonqin.github.io/tags/%E7%89%9B%E5%AE%A2/"},{"name":"面试","slug":"面试","permalink":"https://bowonqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"开源项目","slug":"开源项目","permalink":"https://bowonqin.github.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"eladmin","slug":"eladmin","permalink":"https://bowonqin.github.io/tags/eladmin/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"},{"name":"实战项目","slug":"实战项目","permalink":"https://bowonqin.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"},{"name":"Vue","slug":"Vue","permalink":"https://bowonqin.github.io/tags/Vue/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://bowonqin.github.io/tags/SpringSecurity/"}]}