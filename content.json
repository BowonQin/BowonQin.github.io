{"meta":{"title":"Bowon Qin","subtitle":"Bowon Qin 的Blog","description":"java后端相关技术栈","author":"Bowon Qin","url":"https://bowonqin.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-12-16T06:00:51.035Z","comments":true,"path":"404.html","permalink":"https://bowonqin.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-12-16T06:00:51.250Z","comments":true,"path":"about/index.html","permalink":"https://bowonqin.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-12-16T06:00:51.251Z","comments":true,"path":"archives/index.html","permalink":"https://bowonqin.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-24T16:00:00.000Z","updated":"2021-12-16T11:07:27.488Z","comments":true,"path":"categories/index.html","permalink":"https://bowonqin.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-12-16T06:00:51.255Z","comments":true,"path":"friends/index.html","permalink":"https://bowonqin.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-12-16T06:00:51.257Z","comments":true,"path":"resource/index.html","permalink":"https://bowonqin.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-12-16T06:00:51.257Z","comments":true,"path":"tags/index.html","permalink":"https://bowonqin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis(高级)","slug":"mabatis/Mybatis(高级)","date":"2021-12-18T16:00:00.000Z","updated":"2021-12-19T13:58:15.357Z","comments":true,"path":"posts/333222.html","link":"","permalink":"https://bowonqin.github.io/posts/333222.html","excerpt":"","text":"MyBatis缓存一级缓存1） 在一个sqlSession中，对User表根据id进行两次查询，查看他们发出sql语句的情况 public class CacheTest { private IUserMapper userMapper; private SqlSession sqlSession; @BeforeEach public void before() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); sqlSession = sqlSessionFactory.openSession(); userMapper = sqlSession.getMapper(IUserMapper.class); } @Test public void firstLevelCache(){ User user1 = userMapper.findById(1); User user2 = userMapper.findById(1); System.out.println(user1 == user2); sqlSession.close(); } } 查看控制台输出情况 ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, liutao, null, null &lt;== Total: 1 true 就是在第一次查询时，发出了上面的sql语句，然后在第二次查询时没有发出查询的sql语句。 2） 同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作 @Test public void firstLevelCache(){ User user1 = userMapper.findById(1); // update User user = new User(); user.setId(1); user.setUsername(\"liutao\"); user.setPassword(user1.getPassword()); user.setBirthday(user1.getBirthday()); userMapper.updateUser(user); sqlSession.commit(); User user2 = userMapper.findById(1); System.out.println(user1 == user2); } 查看控制台输出情况 ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, sss, 123, 2019-12-12 &lt;== Total: 1 ==&gt; Preparing: update user set username=?,password=?,birthday=? where id=? ==&gt; Parameters: liutao(String), 123(String), 2019-12-12(String), 1(Integer) &lt;== Updates: 1 Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@47f9738] ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, liutao, 123, 2019-12-12 &lt;== Total: 1 false 总结 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从 数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。 如果中间sqlSession去执行commit操作（执行插入、更新、删除）或者手动关闭缓存，则会清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直 接从缓存中获取用户信息。 一级缓存原理探究和源码分析一级缓存到底是什么？一级缓存什么时候被创建、一级缓存的工作流程是怎样的？相信你现在应该会有这几个疑问，那么我们本节就来研究一下一级缓存的本质。 大家可以这样想，上面我们一直提到一级缓存，那么提到一级缓存就绕不开SqlSession,所以索性我们就直接从SqlSession，看看有没有创建缓存或者与缓存有关的属性或者方法。 调研了一圈，发现上述所有方法中，好像只有clearCache()和缓存沾点关系，那么就直接从这个方 法入手吧，分析源码时，我们要看它(此类)是谁，它的父类和子类分别又是谁，对如上关系了解了，你才 会对这个类有更深的认识，分析了一圈，你可能会得到如下这个流程图。 再深入分析，流程走到Perpetualcache中的clear()方法之后，会调用其**cache.clear()**方法，那 么这个cache是什么东西呢？点进去发现，cache其实就是private Map cache = new HashMap()；也就是一个Map，所以说cache.clear()其实就是map.clear()，也就是说缓存其实就是本地存放的一个map对象，每一个SqISession都会存放一个map对象的引用，那么这个cache是何 时创建的呢？ 你觉得最有可能创建缓存的地方是哪里呢？我觉得是Executor，为什么这么认为？因为Executor是 执行器，用来执行SQL请求，而且清除缓存的方法也在Executor中执行，所以很可能缓存的创建也很 有可能在Executor中，看了一圈发现Executor中有一个createCacheKey方法，这个方法很像是创 建缓存的方法啊，跟进去看看，你发现createCacheKey方法是由BaseExecutor执行的，代码如下 public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) { CacheKey cacheKey = new CacheKey(); //MappedStatement 的 id // id就是Sql语句的所在位置包名+类名+ SQL名称 cacheKey.update(ms.getId()); // offset 就是 0 cacheKey.update(rowBounds.getOffset()); // limit 就是 Integer.MAXVALUE cacheKey.update(rowBounds.getLimit()); //具体的SQL语句 cacheKey.update(boundSql.getSql()); //后面是update 了 sql中带的参数 cacheKey.update(value); cacheKey.update(this.configuration.getEnvironment().getId()); } 创建缓存key会经过一系列的update方法，udate方法由一个CacheKey这个对象来执行的，这个update方法最终由updateList的list来把五个值存进去. 那么我们回归正题，那么创建完缓存之后该用在何处呢？总不会凭空创建一个缓存不使用吧？绝对不会的，经过我们对一级缓存的探究之后，我们发现一级缓存更多是用于查询操作，毕竟一级缓存也叫做查询缓存吧，为什么叫查询缓存我们一会儿说。我们先来看一下这个缓存到底用在哪了，我们跟踪到query方法如下： @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException { BoundSql boundSql = ms.getBoundSql(parameter); //创建缓存 CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql); } @SuppressWarnings(\"unchecked\") @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { ... list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) { //这个主要是处理存储过程用的。 handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); } else { list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); } ... } // queryFromDatabase 方法 private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { List&lt;E&gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); try {list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); } finally { localCache.removeObject(key); } localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) { localOutputParameterCache.putObject(key, parameter); } return list; } 如果查不到的话，就从数据库查，在queryFromDatabase中，会对localcache进行写入。 localcache对象的put方法最终交给Map进行存放。 private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); @Override public void putObject(Object key, Object value) { cache.put(key, value); } 二级缓存二级缓存的原理和一级缓存原理一样，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去缓存中取。但是一级缓存是基于sqlSession的，而二级缓存是基于mapper文件的namespace的，也就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果两个mapper的namespace 相同，即使是两个mapper,那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域 中。 ​ ​ 如何使用二级缓存 和一级缓存默认开启不一样，二级缓存需要我们手动开启首先在全局配置文件sqlMapConfig.xml文件中加入如下代码: &lt;!--开启二级缓存--&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; 其次在UserMapper.xml文件中开启缓存 &lt;!--开启二级缓存--&gt; &lt;cache&gt;&lt;/cache&gt; 或者在UserMapper接口中添加注解 @CacheNamespace(implementation = PerpetualCache.class) 我们可以看到mapper.xml文件中就这么一个空标签，其实这里可以配置,PerpetualCache这个类是mybatis默认实现缓存功能的类。我们不写type就使用mybatis默认的缓存，也可以去实现Cache接口来自定义缓存。 其中，PerpetualCache是MyBatis默认实现的缓存类，Cache是自定义缓存必须实现的缓存接口。 public class PerpetualCache implements Cache { private final String id; private Map&lt;Object, Object&gt; cache = new HashMapC); public PerpetualCache(String id) { this.id = id; } 我们可以看到二级缓存底层还是HashMap结构 开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中，如果我们要再取 这个缓存的话，就需要反序列化了。所以mybatis中的pojo都去实现Serializable接口。 public class User implements Serializable { private Integer id; private String username; private String password; private String birthday; } 测试一、测试二级缓存和sqlSession无关 @Test public void secondLevelCache() { SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); SqlSession sqlSession3 = sqlSessionFactory.openSession(); IUserMapper mapper1 = sqlSession1.getMapper(IUserMapper.class); IUserMapper mapper2 = sqlSession2.getMapper(IUserMapper.class); IUserMapper mapper3 = sqlSession3.getMapper(IUserMapper.class); User user1 = mapper1.findById(1); // 清空一级缓存 sqlSession1.close(); //第二次查询，即使sqlSession1已经关闭了，这次查询依然不发出sql语句 User user2 = mapper2.findById(1); System.out.println(user1 == user2); //false 二级缓存的是数据不是对象 } 可以看出上面两个不同的sqlSession,第一个关闭了，第二次查询依然不发出sql查询语句 二、测试执行commit()操作，二级缓存数据清空 @Test public void secondLevelCache() { SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); SqlSession sqlSession3 = sqlSessionFactory.openSession(); IUserMapper mapper1 = sqlSession1.getMapper(IUserMapper.class); IUserMapper mapper2 = sqlSession2.getMapper(IUserMapper.class); IUserMapper mapper3 = sqlSession3.getMapper(IUserMapper.class); //第一次查询，发出sql语句，并将查询的结果放入缓存中 User user1 = mapper1.findById(1); // 清空一级缓存 sqlSession1.close(); User user = new User(); user.setId(1); user.setUsername(\"lisi\"); user.setPassword(\"123\"); user.setBirthday(\"2020-1-1\"); //执行更新操作，commit() mapper3.updateUser(user); sqlSession3.commit(); //第二次查询，由于上次更新操作，缓存数据已经清空(防止数据脏读)，这里必须再次发出sql语句 User user2 = mapper2.findById(1); System.out.println(user1 == user2); } 控制台情况 Cache Hit Ratio [com.qxd.mapper.IUserMapper]: 0.0 Opening JDBC Connection Created connection 461591680. Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1b835480] ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, lisi, 123, 2020-1-1 &lt;== Total: 1 Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1b835480] Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1b835480] Returned connection 461591680 to pool. Opening JDBC Connection Checked out connection 461591680 from pool. Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1b835480] ==&gt; Preparing: update user set username=?,password=?,birthday=? where id=? ==&gt; Parameters: lisi(String), 123(String), 2020-1-1(String), 1(Integer) &lt;== Updates: 1 Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1b835480] Cache Hit Ratio [com.qxd.mapper.IUserMapper]: 0.0 Opening JDBC Connection Created connection 1631227617. Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@613a8ee1] ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, lisi, 123, 2020-1-1 &lt;== Total: 1 false useCache和flushCache mybatis中还可以配置userCache和flushCache等配置项，userCache是用来设置是否禁用二级缓 存的，在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出 sql去查询，默认情况是true,即该sql使用二级缓存 &lt;select id=\"selectUserByUserId\" useCache=\"false\" resultType=\"com.lagou.pojo.User\" parameterType=\"int\"&gt; select * from user where id=#{id} &lt;/select&gt; 这种情况是针对每次查询都需要最新的数据sql,要设置成useCache=false，禁用二级缓存，直接从数据库中获取。在mapper的同一个namespace中，如果有其它insert、update, delete操作数据后需要刷新缓 存，如果不执行刷新缓存会出现脏读。 设置statement配置中的flushCache=”true”属性，默认情况下为true,即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。 &lt;select id=\"selectUserByUserId\" flushCache=\"true\" useCache=\"false\" resultType=\"com.lagou.pojo.User\" parameterType=\"int\"&gt; select * from user where id=#{id} &lt;/select&gt; 一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。所以我们不用设置，默认即可。","categories":[{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"}],"author":"qxd"},{"title":"Mysql(数据库概述)","slug":"mysql/第01章_数据库概述","date":"2021-12-18T16:00:00.000Z","updated":"2021-12-19T14:23:33.791Z","comments":true,"path":"posts/18293.html","link":"","permalink":"https://bowonqin.github.io/posts/18293.html","excerpt":"","text":"第01章_数据库概述康师傅（宋红康老师）听课笔记 BILIBILI听课网址：[宋红康]MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili 1. 为什么要使用数据库 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 生活中的例子： 2. 数据库与数据库管理系统2.1 数据库的相关概念 DB：数据库（Database） 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。 DBMS：数据库管理系统（Database Management System） 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。 SQL：结构化查询语言（Structured Query Language） 专门用来与数据库通信的语言。 2.2 数据库与数据库管理系统的关系数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。 数据库管理系统、数据库和表的关系如图所示： 2.3 常见的数据库管理系统排名(DBMS)目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。以下是2021年DB-Engines Ranking 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:https://db-engines.com/en/ranking） 。。。 对应的走势图：（https://db-engines.com/en/ranking_trend） 2.4 常见的数据库介绍Oracle 1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。 2007年，总计85亿美金收购BEA Systems。 2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。 2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。 如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。 SQL Server SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。 DB2 IBM公司的数据库产品,收费的。常应用在银行系统中。 PostgreSQL PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。 SyBase 已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。 SQLite 嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。 informix IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。 3. MySQL介绍 3.1 概述 MySQL是一个开放源代码的关系型数据库管理系统，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。 2008被Sun收购（10亿美金），2009年Sun被Oracle收购。MariaDB应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB） MySQL6.x 版本之后分为社区版和商业版。 MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL是开源的，所以你不需要支付额外的费用。 MySQL是可以定制的，采用了GPL（GNU General Public License）协议，你可以修改源码来开发自己的MySQL系统。 MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。 MySQL使用标准的SQL数据语言形式。 MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。 3.2 MySQL发展史重大事件MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。 1.4 关于MySQL 8.0MySQL从5.7版本直接跳跃发布了8.0版本，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。 1.5 Why choose MySQL? 为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点： 开放源代码，使用成本低。 性能卓越，服务稳定。 软件体积小，使用简单，并且易于维护。 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。 许多互联网公司在用，经过了时间的验证。 1.6 Oracle vs MySQLOracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。 MySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。 4. RDBMS 与 非RDBMS从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。 4.1 关系型数据库(RDBMS)4.1.1 实质 这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。 关系型数据库以行(row)和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table)，一组表组成了一个库(database)。 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。 SQL 就是关系型数据库的查询语言。 4.1.2 优势 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。 4.2 非关系型数据库(非RDBMS)4.2.1 介绍非关系型数据库，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。同时，通过减少不常用的功能，进一步提高性能。 目前基本上大部分主流的非关系型数据库都是免费的。 4.2.2 有哪些非关系型数据库相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。 键值型数据库 键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。 键值型数据库典型的使用场景是作为内存缓存。Redis 是最流行的键值型数据库。 文档型数据库 此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。 搜索引擎数据库 虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。 典型产品：Solr、Elasticsearch、Splunk 等。 列式数据库 列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。 图形数据库 图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。 图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。 4.2.3 NoSQL的演变由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 NoSQL 功能的演变： 1970：NoSQL = We have no SQL 1980：NoSQL = Know SQL 2000：NoSQL = No SQL! 2005：NoSQL = Not only SQL 2013：NoSQL = No, SQL! NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。 4.3 小结NoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有必要的。整套课程将围绕 SQL 展开。 5. 关系型数据库设计规则 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。 将数据放到表中，表再放到库中。 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。 5.1 表、记录、字段 E-R（entity-relationship，实体-联系）模型中有三个主要概念是：实体集、属性、联系集。 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。 ORM思想 (Object Relational Mapping)体现： 数据库中的一个表 &lt;---&gt; Java或Python中的一个类 表中的一条数据 &lt;---&gt; 类中的一个对象（或实体） 表中的一个列 &lt;----&gt; 类中的一个字段、属性(field) 5.2 表的关联关系 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。 四种：一对一关联、一对多关联、多对多关联、自我引用 5.2.1 一对一关联（one-to-one） 在实际的开发中应用不多，因为一对一可以创建成一张表。 举例：设计学生表：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、… 拆为两个表：两个表的记录是一一对应关系。 基础信息表（常用信息）：学号、姓名、手机号码、班级、系别 档案信息表（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、… 两种建表原则： 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 外键是主键：主表的主键和从表的主键，形成主外键关系。 5.2.2 一对多关系（one-to-many） 常见实例场景：客户表和订单表，分类表和商品表，部门表和员工表。 举例： 员工表：编号、姓名、…、所属部门 部门表：编号、名称、简介 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键 5.2.3 多对多（many-to-many）要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。 举例1：学生-课程 学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…） 课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介…） 选课信息表：一个学生可以选多门课，一门课可以被多个学生选择 学号 课程编号 1 1001 2 1001 1 1002 举例2：产品-订单 “订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。 产品表：“产品”表中的每条记录表示一个产品。 订单表：“订单”表中的每条记录表示一个订单。 订单明细表：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。 举例3：用户-角色 多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。 5.3.4 自我引用(Self reference)","categories":[{"name":"Mysql篇","slug":"Mysql篇","permalink":"https://bowonqin.github.io/categories/Mysql%E7%AF%87/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://bowonqin.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://bowonqin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"qxd"},{"title":"Mybatis(基础)","slug":"mabatis/Mybatis(基础)","date":"2021-12-16T16:00:00.000Z","updated":"2021-12-18T14:54:41.574Z","comments":true,"path":"posts/1111222.html","link":"","permalink":"https://bowonqin.github.io/posts/1111222.html","excerpt":"","text":"Mybatis相关概念ORM(对象关系数据库映射) ORM全称Object/Relation Mapping：表示对象-关系映射的缩写 ORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层SQL操作。ORM框架实现的效果：把对持久化对象的保存、修改、删除等操作，转换为对数据库的操作 Mybatis简介 MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO （Plain Old Java Objects,普通老式Java对 象）为数据库中的记录。 Mybatis历史 原是apache的一个开源项目iBatis, 2010年6月这个项目由apache software foundation 迁移到了google code，随着开发团队转投Google Code旗下，ibatis3.x正式更名为Mybatis ，代码于2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects(DAO) Mybatis优势 Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。 Mybatis基本应用 Mybatis官网地址：http://www.mybatis.org/mybatis-3/ 快速入门开发步骤： 添加Mybatis坐标 创建user数据表 编写User实体类 编写映射文件UserMapper.xml 编写核心文件SqlMapperConfig.xml 编写测试类 环境搭建1）导入MyBatis的坐标和其他相关坐标 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--mybatis坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--单元测试坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建数据库表 3）编写User实体 public class User { private Integer id; private String username; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + '}'; } } 编写UserMapper映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"user\"&gt; &lt;!-- namespace命名空间，与id组成sql的唯一标识 resultType: 返回值类型 --&gt; &lt;select id=\"findAll\" resultType=\"com.qxd.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 编写Mybatis核心配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写测试类 public class MybatisTest { @Test public void test1() throws IOException { // 加载核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); //获得sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得sqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句 List&lt;User&gt; users = sqlSession.selectList(\"user.findAll\"); // 打印结果 for (User : users) { System.out.println(user); } // 释放资源 sqlSession.close(); } } 打印结果为： User{id=1, username='qqq'} User{id=2, username='zhangsan'} User{id=4, username='null'} Mybatis的增删改查操作Mybatis的插入数据操作 编写UserMapper映射文件 &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"com.qxd.pojo.User\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 编写测试类 @Test public void test2() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(3); user.setUsername(\"sd\"); sqlSession.insert(\"user.saveUser\",user); sqlSession.commit(); sqlSession.close(); } 插入操作注意问题 插入语句使用insert标签 在映射文件中使用parameterType属性指定要插入的数据类型 Sql语句中使用#{实体属性名}方式引用实体中的属性值 插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); 插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() Mybatis的修改数据操作 编写UserMapper映射文件 &lt;!-- 修改--&gt; &lt;mapper&gt; &lt;update id=\"update\" parameterType=\"com.qxd.pojo.User\"&gt; update user set username=#{username} where id = #{id} &lt;/update&gt; &lt;/mapper&gt; 编写测试类 @Test public void test3() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(1); user.setUsername(\"xxx\"); int update = sqlSession.update(\"user.update\", user); System.out.println(update); sqlSession.commit(); sqlSession.close(); } 修改操作注意问题 修改语句使用update标签 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); Mybatis的删除数据操作 编写UserMapper映射文件 &lt;mapper&gt; &lt;!-- 删除--&gt; &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 编写测试类 // 删除 public void test4() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int delete = sqlSession.delete(\"user.delete\", 5); System.out.println(delete); sqlSession.commit(); sqlSession.close(); } 删除操作注意问题 删除语句使用delete标签 Sql语句中使用#{任意字符串}方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); Mybatis的映射文件概述 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--映射文件DTD约束头--&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!--mapper为根标签--&gt; &lt;mapper namespace=\"user\"&gt; &lt;!-- namespace命名空间，与id组成sql的唯一标识 resultType: 返回值类型 --&gt; &lt;select id=\"findAll\" resultType=\"com.qxd.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; Mybatis常用映射文件解析1） environments标签 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--当前运行环境--&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据源配置的基本餐宿--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mapper标签 该标签的作用是加载映射的，加载方式有如下几种： &lt;!--使用相对于类路径的资源引用，例如：--&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;!--使用完全限定资源定位符（URL），例如： --&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;!--使用映射器接口实现类的完全限定类名，例如： --&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!--将包内的映射器接口实现全部注册为映射器，例如：--&gt; &lt;mapper name=\"org.mybatis.builder\"/&gt; Mybatis相应API SqlSession工厂构建器SqlSessionFactoryBuilder 常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 SqlSession工厂对象SqlSessionFactory SqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： // 默认为false,需要手动开启事务 SqlSession sqlSession = sqlSessionFactory.openSession(); // 手动提交事务 sqlSession.commit() // -----------------------------------------------------------------------------// // 自动开启事务，无需手动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); SqlSession会话对象 SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有 &lt;T&gt; T selectOne(String statement, Object parameter); &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter); int insert(String statement, Object parameter); int update(String statement, Object parameter); int delete(String statement, Object parameter); 操作事务的方法主要有： void commit() void rollback() Mybatis的Dao层实现传统开发方式 编写UserDao接口 public interface IUserDao { // 查询所有用户 public List&lt;User&gt; findAll() throws IOException; } 编写UserDaoImpl实现 public class UserDaoImpl implements IUserDao { @Override public List&lt;User&gt; findAll() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; users = sqlSession.selectList(\"user.findAll\"); sqlSession.close(); return users; } } 测试传统方式 @Test public void test5() throws IOException { IUserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); for (User user : all) { System.out.println(user); } } 代理开发方式 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范：、 1） Mapper.xml中的namespace与mapper接口的全限类名相同。 2） Mapper接口方法名和Mapper.xm中定义的每个statemen的id相同 3） Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4） Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 测试代理方法 @Test public void test6() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); IUserDao userDao = sqlSession.getMapper(IUserDao.class); List&lt;User&gt; all = userDao.findAll(); for (User user : all) { System.out.println(user); } sqlSession.close(); } Mybatis配置文件深入核心配置文件environments标签&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--当前运行环境--&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据源配置的基本餐宿--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mapper标签该标签的作用是加载映射的，加载方式有如下几种： &lt;!--使用相对于类路径的资源引用，例如：--&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;!--使用完全限定资源定位符（URL），例如： --&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;!--使用映射器接口实现类的完全限定类名，例如： --&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!--将包内的映射器接口实现全部注册为映射器，例如：--&gt; &lt;mapper name=\"org.mybatis.builder\"/&gt; Properties标签实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 加载外部properties --&gt; &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; typeAliases标签类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"com.qxd.pojo.User\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 配置typeAliases，为com.lagou.domain.User定义别名为user &lt;typeAliases&gt; &lt;!-- 单独实体起别名 --&gt; &lt;typeAlias type=\"com.qxd.pojo.User\" alias=\"user\"&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"user\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 批量起别名:该包下所有类的本身的类名：别名不区分大小写 &lt;!-- 给实体类的全限定类名起别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量起别名：该包下所有类的本身的类名：别名不区分大小写--&gt; &lt;package name=\"com.qxd.pojo\"/&gt; &lt;/typeAliases&gt; 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean …… …… 映射配置文件mapper.xml动态sql语句动态 SQL 之 我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 &lt;!-- 多条件组合查询--&gt; &lt;select id=\"findByCondition\" resultType=\"user\" parameterType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"id != null\"&gt; and id = #{id} &lt;/if&gt; &lt;if test=\"username !=null\"&gt; and username = #{username} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 动态 SQL 之 循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 &lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=\"array\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; foreach标签的属性含义如下： 标签用于遍历集合，它的属性： collection: 代表要遍历的集合元素，注意编写时不要写#{}。 open：代表语句的开始部分。 close：代表结束部分。 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 SQL片段抽取 Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 &lt;!-- 抽取mysql片段--&gt; &lt;sql id=\"selectUser\"&gt; select * from User &lt;/sql&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;/select&gt; Mybatis复杂映射开发一对一查询一对一查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询语句对应的sql语句： select * from orders o,user u where o.uid=u.id; 查询的结果如下： 创建Order和User实体public class Order { private Integer id; private String ordertime; private Double total; //代表当前订单从属于哪一个客户 private User user; get() set() } public class User { private Integer id; private String username; private String password; private String birthday; get() set() } 创建IUserMapper接口public interface IUserMapper { // 查询订单的同时还查询该订单所属的用户 public List&lt;Order&gt; findOrderAndUser(); } 配置IUserMapper.xml&lt;mapper namespace=\"com.qxd.mapper.IUserMapper\"&gt; &lt;!--resultMap:手动配置实体属性和表字段的映射关系 --&gt; &lt;resultMap id=\"orderMap\" type=\"com.qxd.pojo.Order\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"orderTime\" column=\"orderTime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"com.qxd.pojo.User\"&gt; &lt;result property=\"id\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findOrderAndUser\" resultMap=\"orderMap\"&gt; select * from orders o,user u where o.uid=u.id; &lt;/select&gt; &lt;/mapper&gt; 其中，sqlMapperConfig.xml导包的时候可以做如下配置 &lt;mappers&gt; &lt;!--同包同名--&gt; &lt;package name=\"com.qxd.mapper\"/&gt; &lt;/mappers&gt; 其中，使用package标签导包的时候要保证mapper.xml与mapper接口同包同名才能成功。 一对多查询模型一对多查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询语句对应的sql语句： select *,o.id oid from user u left join orders o on u.id=o.uid; 查询的结果如下： 修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); } public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; } 创建IUserMapper接口public interface IUserMapper { // 查询所有用户拥有的订单 public List&lt;User&gt; findAll(); } 配置IUserMapper.xml&lt;mapper&gt; &lt;resultMap id=\"userMap\" type=\"com.qxd.pojo.User\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!--集合类型+泛型--&gt; &lt;collection property=\"orderList\" ofType=\"com.qxd.pojo.Order\"&gt; &lt;result property=\"id\" column=\"oid\"&gt;&lt;/result&gt; &lt;result property=\"orderTime\" column=\"orderTime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select *,o.id oid from user u left join orders o on u.id=o.uid; &lt;/select&gt; &lt;/mapper&gt; 多对多查询多对多查询模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询语句对应的sql语句： SELECT u.*, r.*, r.id rid FROM USER u LEFT JOIN sys_user_role ur ON u.id = ur.userid LEFT JOIN sys_role r ON ur.roleid = r.id; 查询结果如下 创建Role实体，修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); // 表示用户当前的角色 private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); } public class Role { private Integer id; private String roleName; private String roleDesc; } 添加UserMapper接口方法// 查询所有用户拥有的角色 public List&lt;User&gt; findAllUserAndRole(); 配置IUserMapper.xml&lt;mapper&gt; &lt;resultMap id=\"userRoleMap\" type=\"user\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;collection property=\"roleList\" ofType=\"Role\"&gt; &lt;result property=\"id\" column=\"rid\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"roleDesc\"&gt;&lt;/result&gt; &lt;result property=\"roleName\" column=\"roleName\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAllUserAndRole\" resultMap=\"userRoleMap\"&gt; SELECT u.*, r.*, r.id rid FROM USER u LEFT JOIN sys_user_role ur ON u.id = ur.userid LEFT JOIN sys_role r ON ur.roleid = r.id; &lt;/select&gt; &lt;/mapper&gt; 知识小结一对一配置： 使用做配置 一对多配置： 使用+做配置 多对多配置： 使用+做配置 Mybatis注解开发MyBatis常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 Mybatis增删改查我们完成简单的user表的增删改查的操作 private IUserMapper userMapper; @BeforeEach public void before() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(IUserMapper.class); } @Test public void addUserTest() throws IOException { User user = new User(); user.setId(6); user.setUsername(\"qqq\"); user.setBirthday(\"2021-1-1\"); user.setPassword(\"123321\"); userMapper.addUser(user); } @Test public void selectUserTest(){ List&lt;User&gt; users = userMapper.selectUsers(); for (User user : users) { System.out.println(user); } } @Test public void udpateUserTest(){ User user = new User(); user.setId(6); user.setUsername(\"xxx\"); user.setBirthday(\"2021-11-1\"); user.setPassword(\"1233221\"); userMapper.updateUser(user); } @Test public void deleteUserTest(){ userMapper.delete(6); } MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 一对一查询一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句select * from orders; select * from user where id=查询出订单的uid; 创建Order和User实体public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; get set toString() } public class User { private Integer id; private String username; private String password; private String birthday; get set toString() } 创建OrderMapper接口public interface IOrderMapper { public List&lt;Order&gt;findAll(); } 使用注解配置Mapperpublic interface IOrderMapper { @Select(\"select * from orders\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"orderTime\",column = \"ordertime\"), @Result(property = \"total\",column = \"total\"), @Result(property = \"user\",column = \"uid\",javaType = User.class,one = @One(select = \"com.qxd.mapper.IUserMapper.findById\")), }) public List&lt;Order&gt;findAll(); } public interface IUserMapper{ @Select(\"select * from user where id=#{id}\") public User findById(Integer id); } 测试结果 @Test public void testSelectOrderAndUser() { List&lt;Order&gt; all = orderMapper.findAll(); for (Order order : all) { System.out.println(order); } } // 打印结果 Order{id=1, orderTime=2019-12-12, total=3000.0, user=User{id=1, username='lucy', password='123', birthday='2019-12-12} Order{id=2, orderTime=2019-12-12, total=4000.0, user=User{id=1, username='lucy', password='123', birthday='2019-12-12} Order{id=3, orderTime=2019-12-12, total=5000.0, user=User{id=2, username='tom', password='123', birthday='2019-12-12} 一对多查询一对多查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询的语句对应的sql语句： select * from user; select * from orders where uid=查询出用户的id; 修改Order和User实体public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; get set toString() } public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); get set toString() } 创建UserMapper接口public interface IUserMapper { public List&lt;User&gt; findOrderAndUserByAnnotation(); } 使用注解配置Mapperpublic interface IUserMapper { // 查询订单的同时还查询该订单所属的用户 @Select(\"select * from user\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"orderList\",column = \"id\",javaType = List.class,many = @Many(select = \"com.qxd.mapper.IOrderMapper.findByUid\")), }) public List&lt;User&gt; findOrderAndUserByAnnotation(); } public interface IOrderMapper { @Select(\"select * from orders where uid=#{uid}\") public Order findByUid(Integer uid); } 测试结果 @Test public void testSelectUserAndOrder(){ List&lt;User&gt; orderAndUserByAnnotation = userMapper.findOrderAndUserByAnnotation(); for (User user : orderAndUserByAnnotation) { System.out.println(user); } } // 打印结果 User{id=1, username='lucy', password='123', birthday='2019-12-12', orderList=[Order{id=1, orderTime='2019-12-12', total=3000.0}, Order{id=2, orderTime='2019-12-12', total=4000.0}]} User{id=2, username='tom', password='123', birthday='2019-12-12', orderList=[Order{id=3, orderTime='2019-12-12', total=5000.0}]} User{id=3, username='jack', password='123', birthday='2017-1-1', orderList=[]} User{id=5, username='qqq', password='123321', birthday='2021-1-1', orderList=[]} 多对多查询多对多查询模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询语句select * from user; select * from role r, sys_user_role ur where r.id=ur.roleid and ur.userid=用户的id 创建Role实体，修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 // private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); // 表示用户当前的角色 private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); get set toString } public class Role { private Integer id; private String roleName; private String roleDesc; get set toString } 添加UserMapper接口方法public interface IUserMapper { public List&lt;User&gt; findOrderAndUserByAnnotation(); } 使用注解配置Mapperpublic interface IUserMapper{ @Select(\"select * from user\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"roleList\",column = \"id\",javaType = List.class,many = @Many(select = \"com.qxd.mapper.IRoleMapper.findRoleByUid\")), }) public List&lt;User&gt; findUserAndRoleByAnnotation(); } public interface IRoleMapper{ @Select(\"select * from sys_role r, sys_user_role ur where r.id=ur.roleid and ur.userid=#{uid}\") public Role findRoleByUid(Integer uid); } 测试结果 @Test public void testUserAndRole(){ List&lt;User&gt; userAndRoleByAnnotation = userMapper.findUserAndRoleByAnnotation(); for (User user : userAndRoleByAnnotation) { System.out.println(user); } } // 打印结果 User{id=1, username='lucy', password='123', birthday='2019-12-12', roleList=[Role{id=1, roleName='CTO', roleDesc='CTO'}, Role{id=2, roleName='CEO', roleDesc='CEO'}]} User{id=2, username='tom', password='123', birthday='2019-12-12', roleList=[Role{id=1, roleName='CTO', roleDesc='CTO'}, Role{id=2, roleName='CEO', roleDesc='CEO'}]} User{id=3, username='jack', password='123', birthday='2017-1-1', roleList=[]} User{id=5, username='qqq', password='123321', birthday='2021-1-1', roleList=[]}","categories":[{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"}],"author":"qxd"},{"title":"牛客高频面试题","slug":"常见面试题总结/牛客100","date":"2021-12-16T16:00:00.000Z","updated":"2021-12-17T14:20:56.882Z","comments":true,"path":"posts/niuke100.html","link":"","permalink":"https://bowonqin.github.io/posts/niuke100.html","excerpt":"","text":"字符串搜索-BF和RK 给定两个字符串A、B，判断B在A中是否存在，存在返回A中的下标，不存在返回-1 例如： A：ABCABCABCCCAAA ​ B: BCCCA 返回值 6 java中的String.indexOf()方法可以实现 BF暴力算法逐字符地进行匹配（比较A[i]和B[j]）,如果当前字符匹配成功（A[i] == B[j]），就匹配下一个字符（++i,++j），如果失配，i回溯，j置为0（i = i-j+1,j=0） 时间复杂度为O(n*m)，与主串和模式串的长度正相关 // pat匹配串 // txt原串 int search(String pat, String txt) { if (pat == null || txt == null) { return -1; } int M = pat.length(); int N = txt.length(); for (int i = 0; i &lt; N - M; i++) { int j; for (j = 0; j &lt; M; j++) { if (pat.charAt(j) != txt.charAt(i + j)) { break; } } // pat全部匹配了 if (j == M) return i; } return -1; } RK算法：hash算法基于BF进行优化，将A字符按顺序和B串的长度进行截取。两者hash值比对。时间复杂度为O(m*n),hash算法参与的字符位数（模式串的长度）、及主串长度正相关 优化：hash算法：按26位进制取和，abc=1+2+3=6 则每一个字符串的hash值是前一个子串的hash值减去子串最小下标值、加上本串的最大下标值 bcd=abc-a+d=6-1+4=9 时间复杂度变为：O（N）,只与主串长度相关，但是hash冲突极端情况下会退化为BF","categories":[{"name":"面试篇","slug":"面试篇","permalink":"https://bowonqin.github.io/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://bowonqin.github.io/tags/%E7%89%9B%E5%AE%A2/"},{"name":"面试","slug":"面试","permalink":"https://bowonqin.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":"qxd"},{"title":"开源项目eladmin解析（一）","slug":"开源项目/开源项目eladmin(1)","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-17T00:45:00.520Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://bowonqin.github.io/posts/0.html","excerpt":"","text":"前言 作为初学者该如何学习开源项目呢，这里以githu/gitee上一个非常流行的后台管理系统eladmin为例。这里学习的目的是总结和归纳如何对项目进行分模块剖析，以及将拆分的模块快速的应用于新项目中。这里是eladmin的相关链接地址 github 地址 gitee 地址 开发文档 地址 技术栈分析 后端：Springboot、Springboot Jpa、JWT、SpringSecurity、Mysql、Redis 前端：Vue、Element-UI IDE及和可视化工具 IDEA Navicat Another Redis Desktop Manager(Redis可视化工具) （AnotherRedisDesktopManager 发行版 - Gitee.com） 主要特性 使用最新技术栈，社区资源丰富。 高效率开发，代码生成器可一键生成前后端代码 支持数据字典，可方便地对一些状态进行管理 支持接口限流，避免恶意请求导致服务层压力过大 支持接口级别的功能权限与数据权限，可自定义操作 自定义权限注解与匿名接口注解，可快速对接口拦截与放行 对一些常用地前端组件封装：表格数据请求、数据字典等 前后端统一异常拦截处理，统一输出异常，避免繁琐的判断 支持在线用户管理与服务器性能监控，支持限制单用户登录 支持运维管理，可方便地对远程服务器的应用进行部署与管理 主要功能 用户管理：提供用户的相关配置，新增用户后，默认密码为123456 角色管理：对权限与菜单进行分配，可根据部门设置角色的数据权限 菜单管理：已实现菜单动态路由，后端可配置化，支持多级菜单 部门管理：可配置系统组织架构，树形表格展示 岗位管理：配置各个部门的职位 字典管理：可维护常用一些固定的数据，如：状态，性别等 系统日志：记录用户操作日志与异常日志，方便开发人员定位排错 SQL监控：采用druid 监控数据库访问性能，默认用户名admin，密码123456 定时任务：整合Quartz做定时任务，加入任务日志，任务运行情况一目了然 代码生成：高灵活度生成前后端代码，减少大量重复的工作任务 邮件工具：配合富文本，发送html格式的邮件七牛云存储：可同步七牛云存储的数据到系统，无需登录七牛云直接操作云数据 支付宝支付：整合了支付宝支付并且提供了测试账号，可自行测试 服务监控：监控服务器的负载情况 运维管理：一键部署你的应用 项目结构 eladmin-common 为系统的公共模块，各种工具类，公共配置存在该模块 eladmin-system 为系统核心模块也是项目入口模块，也是最终需要打包部署的模块 eladmin-logging 为系统的日志模块，其他模块如果需要记录日志需要引入该模块 eladmin-tools 为第三方工具模块，包含：图床、邮件、云存储、本地存储、支付宝 eladmin-generator 为系统的代码生成模块，代码生成的模板在 system 模块中 详细结构- eladmin-common 公共模块 - annotation 为系统自定义注解 - aspect 自定义注解的切面 - base 提供了Entity、DTO基类和mapstruct的通用mapper - config 自定义权限实现、redis配置、swagger配置、Rsa配置等 - exception 项目统一异常的处理 - utils 系统通用工具类 - eladmin-system 系统核心模块（系统启动入口） - config 配置跨域与静态资源，与数据权限 - thread 线程池相关 - modules 系统相关模块(登录授权、系统监控、定时任务、运维管理等) - eladmin-logging 系统日志模块 - eladmin-tools 系统第三方工具模块 - eladmin-generator 系统代码生成模块","categories":[{"name":"开源项目篇","slug":"开源项目篇","permalink":"https://bowonqin.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://bowonqin.github.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"eladmin","slug":"eladmin","permalink":"https://bowonqin.github.io/tags/eladmin/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"}],"author":"qxd"},{"title":"Springboot+SpringSecurity+Vue后台管理系统","slug":"实战项目/Springboot+Vue后台管理系统(Vue)","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-17T06:31:45.766Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://bowonqin.github.io/posts/2.html","excerpt":"","text":"安装Vue环境，新建Vue项目 查看nodejs和npm版本信息 安装vue环境 # 安装淘宝npm npm install -g cnpm --registry=https://registry.npm.taobao.org # 安装vue-cli依赖包 cnpm install -g vue-cli # 打开vue可视化管理工具vue ui vue ui 是一个可视化管理工具，可以运行项目、打包项目、检查等操作 按步骤下一步即可 安装Element-uicnpm install element-ui --save 安装成功后，打开项目src中的main.js，引入element-ui的依赖 import Element from \"element-ui\" import \"element-ui/lib/theme-chalk/index.css\" Vue.use(Element); 安装axios、qs、mockjs axios: 一个基于promise的HTTP库，类似ajax 安装： cnpm install axios --save 引入依赖 import axios from 'axios' Vue.prototype.$axios = axios qs: 查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，也可以将一个查询字符串解析成一个object 安装： cnpm install qs --save mockjs: 随机数据工具库 安装： cnpm install axios --save-dev 页面路由 传统项目开发，后端通过链接达到控制器再到页面渲染 前后端分离：先访问页面，然后异步加载数据渲染。路由管理的组件为Router Router: 建立起url和页面之间的映射关系 import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home.vue' Vue.use(VueRouter) const routes = [{ path: '/', name: 'Home', component: Home }, { path: '/login/', name: 'Login', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =&gt; import( /* webpackChunkName: \"about\" */ '../views/Login.vue') } ] const router = new VueRouter({ routes, mode: 'history' //去除#号 }) export default router 通过访问 http://localhost:8081/ 可以访问到Home.vue中的内容，这种先import的模式是及急加载模式。 通过访问 http://localhost:8081/login 可以访问到Login.vue中的内容，这种用到组件再import模式是懒加载的模式。 登录页面的开发开发流程： 浏览器打开登录页面 动态加载登录验证码，前后端分离项目不用session进行交互，禁用session。在后端生成验证码同时生成随机码，随机码作为key，验证码作为value存放在redis中，然后把随机码和验证码的Base64字符串发送到前端 前端提交用户名、密码、验证码和随机码 后台验证验证码是否匹配以及密码是否正确 mock.js的设计 const Mock = require(\"mockjs\"); const Random = Mock.Random let Result = { code: 200, msg: '操作成功', data: null } Mock.mock(\"/captcha\", 'get', () =&gt; { Result.data ={ token: Random.string(32), captchaImg: Random.dataImage('100x40','p7n5w') } return Result }) Mock.mock(\"/login\",'post',()=&gt;{ // 无法在header中传入数据 }) 模拟后台发送随机码和Base64编码的验证码 login.vue页面的设计 &lt;template&gt; &lt;el-row type=\"flex\" class=\"row-bg\" justify=\"center\"&gt; &lt;el-col :xl=\"6\" :lg=\"7\"&gt; &lt;h2&gt;欢迎来到VueAdmin管理系统&lt;/h2&gt; &lt;el-image :src=\"require('@/assets/logo.png')\" style=\"height: 180px; width: 180px\" &gt;&lt;/el-image&gt; &lt;/el-col&gt; &lt;!-- 分割线 --&gt; &lt;el-col :span=\"1\"&gt; &lt;el-divider direction=\"vertical\"&gt;&lt;/el-divider&gt; &lt;/el-col&gt; &lt;el-col :xl=\"6\" :lg=\"7\"&gt; &lt;el-form :model=\"LoginForm\" :rules=\"rules\" ref=\"LoginForm\" label-width=\"100px\" class=\"demo-LoginForm\" &gt; &lt;el-form-item label=\"用户名\" prop=\"username\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.username\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"password\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.password\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"验证码\" prop=\"code\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.code\" style=\"width: 172px; float: left\" maxlength=\"5\" &gt;&lt;/el-input&gt; &lt;el-image :src=\"captchaImg\" class=\"captchaImg\" &gt;&lt;/el-image&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" @click=\"submitForm('LoginForm')\" &gt;立即创建&lt;/el-button &gt; &lt;el-button @click=\"resetForm('LoginForm')\"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { LoginForm: { username: \"\", password: \"\", code: \"\", token: \"\", }, rules: { username: [ { required: true, message: \"请输入用户名\", trigger: \"blur\" }, ], password: [{ required: true, message: \"请输入密码\", trigger: \"blur\" }], code: [ { required: true, message: \"请输入验证码\", trigger: \"blur\" }, { min: 5, max: 5, message: \"长度为5个字符\", trigger: \"blur\" }, ], }, captchaImg: null, }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { this.$axios.post(\"/login\", this.LoginForm).then((res) =&gt; { const jwt = res.headers['authorization'] this.$store.commit('SET_TOKEN', jwt) this.$router.push(\"/index\") }); } else { console.log(\"error submit!!\"); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); }, getCaptcha() { this.$axios.get(\"/captcha\").then((res) =&gt; { console.log(\"/captcha\"); console.log(res); this.LoginForm.token = res.data.data.token; this.captchaImg = res.data.data.captchaImg; }); }, }, created() { this.getCaptcha(); }, }; &lt;/script&gt; &lt;style scoped&gt; .el-row { background-color: #fafafa; height: 100vh; display: flex; align-items: center; text-align: center; justify-content: center; } .el-divider { height: 200px; } .captchaImg { float: left; margin-left: 8px; border-radius: 4px; } &lt;/style&gt;","categories":[{"name":"实战项目篇","slug":"实战项目篇","permalink":"https://bowonqin.github.io/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"实战项目","slug":"实战项目","permalink":"https://bowonqin.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"},{"name":"Vue","slug":"Vue","permalink":"https://bowonqin.github.io/tags/Vue/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://bowonqin.github.io/tags/SpringSecurity/"}],"author":"qxd"},{"title":"开源项目eladmin解析（二）","slug":"开源项目/开源项目eladmin(2)","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-17T00:45:04.970Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://bowonqin.github.io/posts/1.html","excerpt":"","text":"登录功能登录流程","categories":[{"name":"开源项目篇","slug":"开源项目篇","permalink":"https://bowonqin.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://bowonqin.github.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"eladmin","slug":"eladmin","permalink":"https://bowonqin.github.io/tags/eladmin/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"}],"author":"qxd"}],"categories":[{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"},{"name":"Mysql篇","slug":"Mysql篇","permalink":"https://bowonqin.github.io/categories/Mysql%E7%AF%87/"},{"name":"面试篇","slug":"面试篇","permalink":"https://bowonqin.github.io/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"name":"开源项目篇","slug":"开源项目篇","permalink":"https://bowonqin.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%AF%87/"},{"name":"实战项目篇","slug":"实战项目篇","permalink":"https://bowonqin.github.io/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"},{"name":"Mysql","slug":"Mysql","permalink":"https://bowonqin.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://bowonqin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"牛客","slug":"牛客","permalink":"https://bowonqin.github.io/tags/%E7%89%9B%E5%AE%A2/"},{"name":"面试","slug":"面试","permalink":"https://bowonqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"开源项目","slug":"开源项目","permalink":"https://bowonqin.github.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"eladmin","slug":"eladmin","permalink":"https://bowonqin.github.io/tags/eladmin/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"},{"name":"实战项目","slug":"实战项目","permalink":"https://bowonqin.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"},{"name":"Vue","slug":"Vue","permalink":"https://bowonqin.github.io/tags/Vue/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://bowonqin.github.io/tags/SpringSecurity/"}]}