{"meta":{"title":"Bowon Qin","subtitle":"Bowon Qin 的Blog","description":"java后端相关技术栈","author":"Bowon Qin","url":"https://bowonqin.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-12-16T06:00:51.035Z","comments":true,"path":"404.html","permalink":"https://bowonqin.github.io/404.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-12-16T06:00:51.251Z","comments":true,"path":"archives/index.html","permalink":"https://bowonqin.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-12-16T06:00:51.250Z","comments":true,"path":"about/index.html","permalink":"https://bowonqin.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-24T16:00:00.000Z","updated":"2021-12-16T11:07:27.488Z","comments":true,"path":"categories/index.html","permalink":"https://bowonqin.github.io/categories/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-12-16T06:00:51.257Z","comments":true,"path":"resource/index.html","permalink":"https://bowonqin.github.io/resource/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-12-16T06:00:51.255Z","comments":true,"path":"friends/index.html","permalink":"https://bowonqin.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-12-16T06:00:51.257Z","comments":true,"path":"tags/index.html","permalink":"https://bowonqin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mysql(MySQL环境搭建)","slug":"mysql/第02章-MySQL环境搭建","date":"2021-12-20T05:38:51.000Z","updated":"2021-12-20T06:12:15.133Z","comments":true,"path":"posts/mysql2.html","link":"","permalink":"https://bowonqin.github.io/posts/mysql2.html","excerpt":"","text":"第02章_MySQL环境搭建康师傅（宋红康老师）听课笔记 BILIBILI听课网址：[宋红康]MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili 1. MySQL的卸载步骤1：停止MySQL服务在卸载之前，先停止MySQL8.0的服务。按键盘上的“Ctrl + Alt + Delete”组合键，打开“任务管理器”对话框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停止”选项停止MySQL8.0的服务，如图所示。 步骤2：软件的卸载方式1：通过控制面板方式 卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中找到MySQL8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着删除。 方式2：通过360或电脑管家等软件卸载 略 方式3：通过安装包提供的卸载功能卸载 你也可以通过安装向导程序进行MySQL8.0服务器程序的卸载。 ① 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已安装的MySQL服务器程序。 ② 选择要卸载的MySQL服务器程序，单击“Remove”（移除），即可进行卸载。 ③ 单击“Next”（下一步）按钮，确认卸载。 ④ 弹出是否同时移除数据目录选择窗口。如果想要同时删除MySQL服务器中的数据，则勾选“Remove the data directory”，如图所示。 ⑤ 执行卸载。单击“Execute”（执行）按钮进行卸载。 ⑥ 完成卸载。单击“Finish”（完成）按钮即可。如果想要同时卸载MySQL8.0的安装向导程序，勾选“Yes，Uninstall MySQL Installer”即可，如图所示。 步骤3：残余文件的清理如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。 （1）服务目录：mysql服务的安装目录 （2）数据目录：默认在C:\\ProgramData\\MySQL 如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可。 注意：请在卸载前做好数据备份 在操作完以后，需要重启计算机，然后进行安装即可。如果仍然安装失败，需要继续操作如下步骤4。 步骤4：清理注册表（选做）如果前几步做了，再次安装还是失败，那么可以清理注册表。 如何打开注册表编辑器：在系统的搜索框中输入regedit HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL服务目录删除 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MySQL服务删除 注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类 步骤5：删除环境变量配置找到path环境变量，将其中关于mysql的环境变量删除，切记不要全部删除。 例如：删除 D:\\develop_tools\\mysql\\MySQLServer8.0.26\\bin; 这个部分 2. MySQL的下载、安装、配置2.1 MySQL的4大版本 MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。 MySQL Enterprise Edition 企业版本，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。 MySQL Cluster 集群版，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。 MySQL Cluster CGE 高级集群版，需付费。 目前最新版本为8.0.27，发布时间2021年10月。此前，8.0.0 在 2016.9.12日就发布了。 本课程中使用8.0.26版本。 此外，官方还提供了MySQL Workbench（GUITOOL）一款专为MySQL设计的图形界面管理工具。MySQLWorkbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL WorkbenchSE）。 2.2 软件的下载1. 下载地址 官网：https://www.mysql.com 2. 打开官网，点击DOWNLOADS 然后，点击MySQL Community(GPL) Downloads 3. 点击 MySQL Community Server 4. 在General Availability(GA) Releases中选择适合的版本 Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。 这里在Windows 系统下推荐下载MSI安装程序；点击Go to Download Page进行下载即可 Windows下的MySQL8.0安装有两种安装程序 mysql-installer-web-community-8.0.26.0.msi 下载程序大小：2.4M；安装时需要联网安装组件。 mysql-installer-community-8.0.26.0.msi 下载程序大小：450.7M；安装时离线安装即可。推荐。 如果安装MySQL5.7版本的话，选择Archives，接着选择MySQL5.7的相应版本即可。这里下载最近期的MySQL5.7.34版本。 2.3 MySQL8.0 版本的安装MySQL下载完成后，找到下载文件，双击进行安装，具体操作步骤如下。 步骤1：双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。 步骤2：打开“Choosing a Setup Type”（选择安装类型）窗口，在其中列出了5种安装类型，分别是Developer Default（默认安装类型）、Server only（仅作为服务器）、Client only（仅作为客户端）、Full（完全安装）、Custom（自定义安装）。这里选择“Custom（自定义安装）”类型按钮，单击“Next(下一步)”按钮。 步骤3：打开“Select Products” （选择产品）窗口，可以定制需要安装的产品清单。例如，选择“MySQL Server 8.0.26-X64”后，单击“→”添加按钮，即可选择安装MySQL服务器，如图所示。采用通用的方法，可以添加其他你需要安装的产品。 此时如果直接“Next”（下一步），则产品的安装路径是默认的。如果想要自定义安装目录，则可以选中对应的产品，然后在下面会出现“Advanced Options”（高级选项）的超链接。 单击“Advanced Options”（高级选项）则会弹出安装目录的选择窗口，如图所示，此时你可以分别设置MySQL的服务程序安装目录和数据存储目录。如果不设置，默认分别在C盘的Program Files目录和ProgramData目录（这是一个隐藏目录）。如果自定义安装目录，请避免“中文”目录。另外，建议服务目录和数据目录分开存放。 步骤4：在上一步选择好要安装的产品之后，单击“Next”（下一步）进入确认窗口，如图所示。单击“Execute”（执行）按钮开始安装。 步骤5：安装完成后在“Status”（状态）列表下将显示“Complete”（安装完成），如图所示。 2.4 配置MySQL8.0MySQL安装之后，需要对服务器进行配置。具体的配置步骤如下。 步骤1：在上一个小节的最后一步，单击“Next”（下一步）按钮，就可以进入产品配置窗口。 步骤2：单击“Next”（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认端口号3306。 其中，“Config Type”选项用于设置服务器的类型。单击该选项右侧的下三角按钮，即可查看3个选项，如图所示。 Development Machine（开发机器）：该选项代表典型个人用桌面工作站。此时机器上需要运行多个应用程序，那么MySQL服务器将占用最少的系统资源。 Server Machine（服务器）：该选项代表服务器，MySQL服务器可以同其他服务器应用程序一起运行，例如Web服务器等。MySQL服务器配置成适当比例的系统资源。 Dedicated Machine（专用服务器）：该选项代表只运行MySQL服务的服务器。MySQL服务器配置成使用所有可用系统资源。 步骤3：单击“Next”（下一步）按钮，打开设置授权方式窗口。其中，上面的选项是MySQL8.0提供的新的授权方式，采用SHA256基础的密码加密方法；下面的选项是传统授权方法（保留5.x版本兼容性）。 步骤4：单击“Next”（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“Add User”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台/哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在MySQL高级特性篇中讲解。 步骤5：单击“Next”（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在Windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“MySQL80”。如果希望开机自启动服务，也可以勾选“Start the MySQL Server at System Startup”选项（推荐）。 下面是选择以什么方式运行服务？可以选择“Standard System Account”(标准系统用户)或者“Custom User”(自定义用户)中的一个。这里推荐前者。 步骤6：单击“Next”（下一步）按钮，打开确认设置服务器窗口，单击“Execute”（执行）按钮。 步骤7：完成配置，如图所示。单击“Finish”（完成）按钮，即可完成服务器的配置。 步骤8：如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择“Next”（下一步），直接完成整个安装和配置过程。 步骤9：结束安装和配置。 2.5 配置MySQL8.0 环境变量如果不配置MySQL环境变量，就不能在命令行直接输入MySQL登录命令。下面说如何配置MySQL的环境变量： 步骤1：在桌面上右击【此电脑】图标，在弹出的快捷菜单中选择【属性】菜单命令。步骤2：打开【系统】窗口，单击【高级系统设置】链接。步骤3：打开【系统属性】对话框，选择【高级】选项卡，然后单击【环境变量】按钮。步骤4：打开【环境变量】对话框，在系统变量列表中选择path变量。步骤5：单击【编辑】按钮，在【编辑环境变量】对话框中，将MySQL应用程序的bin目录（C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin）添加到变量值中，用分号将其与其他路径分隔开。步骤6：添加完成之后，单击【确定】按钮，这样就完成了配置path变量的操作，然后就可以直接输入MySQL命令来登录数据库了。 2.6 MySQL5.7 版本的安装、配置 安装 此版本的安装过程与上述过程除了版本号不同之外，其它环节都是相同的。所以这里省略了MySQL5.7.34版本的安装截图。 配置 配置环节与MySQL8.0版本确有细微不同。大部分情况下直接选择“Next”即可，不影响整理使用。 这里配置MySQL5.7时，重点强调：与前面安装好的MySQL8.0不能使用相同的端口号。 2.7 安装失败问题MySQL的安装和配置是一件非常简单的事，但是在操作过程中也可能出现问题，特别是初学者。 问题1：无法打开MySQL8.0软件安装包或者安装过程中失败，如何解决？ 在运行MySQL8.0软件安装包之前，用户需要确保系统中已经安装了.Net Framework相关软件，如果缺少此软件，将不能正常地安装MySQL8.0软件。 解决方案：到这个地址https://www.microsoft.com/en-us/download/details.aspx?id=42642下载Microsoft .NET Framework 4.5并安装后，再去安装MySQL。 另外，还要确保Windows Installer正常安装。windows上安装mysql8.0需要操作系统提前已安装好Microsoft Visual C++ 2015-2019。 解决方案同样是，提前到微软官网https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0，下载相应的环境。 问题2：卸载重装MySQL失败？ 该问题通常是因为MySQL卸载时，没有完全清除相关信息导致的。 解决办法是，把以前的安装目录删除。如果之前安装并未单独指定过服务安装目录，则默认安装目录是“C:\\Program Files\\MySQL”，彻底删除该目录。同时删除MySQL的Data目录，如果之前安装并未单独指定过数据目录，则默认安装目录是“C:\\ProgramData\\MySQL”，该目录一般为隐藏目录。删除后，重新安装即可。 问题3：如何在Windows系统删除之前的未卸载干净的MySQL服务列表？ 操作方法如下，在系统“搜索框”中输入“cmd”，按“Enter”（回车）键确认，弹出命令提示符界面。然后输入“sc delete MySQL服务名”,按“Enter”（回车）键，就能彻底删除残余的MySQL服务了。 3. MySQL的登录3.1 服务的启动与停止MySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。 在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也自动启动、停止。 方式1：使用图形界面工具 步骤1：打开windows服务 方式1：计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点击） 方式2：控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击） 方式3：任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击） 方式4：单击【开始】菜单，在搜索框中输入“services.msc”，按Enter键确认 步骤2：找到MySQL80（点击鼠标右键）→ 启动或停止（点击） 方式2：使用命令行工具# 启动 MySQL 服务命令： net start MySQL服务名 # 停止 MySQL 服务命令： net stop MySQL服务名 说明： start和stop后面的服务名应与之前配置时指定的服务名一致。 如果当你输入命令后，提示“拒绝服务”，请以系统管理员身份打开命令提示符界面重新尝试。 3.2 自带客户端的登录与退出当MySQL服务启动完成后，便可以通过客户端来登录MySQL数据库。注意：确认服务是开启的。 登录方式1：MySQL自带客户端开始菜单 → 所有程序 → MySQL → MySQL 8.0 Command Line Client 说明：仅限于root用户 登录方式2：windows命令行 格式： mysql -h 主机名 -P 端口号 -u 用户名 -p密码 举例： mysql -h localhost -P 3306 -u root -pabc123 # 这里我设置的root用户的密码是abc123 注意： （1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如： mysql -hlocalhost -P3306 -uroot -pabc123 （2）密码建议在下一行输入，保证安全 mysql -h localhost -P 3306 -u root -p Enter password:**** （3）客户端和服务器在同一台机器上，所以输入localhost或者IP地址127.0.0.1。同时，因为是连接本机：-hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略 简写成： mysql -u root -p Enter password:**** 连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。 也可以在命令行通过以下方式获取MySQL Server服务版本的信息： c:\\&gt; mysql -V c:\\&gt; mysql --version 或登录后，通过以下方式查看当前版本信息： mysql&gt; select version(); 退出登录exit 或 quit 4. MySQL演示使用4.1 MySQL的使用演示1、查看所有的数据库 show databases; “information_schema”是 MySQL 系统自带的数据库，主要保存 MySQL 数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的文件夹，等等 “performance_schema”是 MySQL 系统自带的数据库，可以用来监控 MySQL 的各类性能指标。 “sys”数据库是 MySQL 系统自带的数据库，主要作用是以一种更容易被理解的方式展示 MySQL 数据库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。 “mysql”数据库保存了 MySQL 数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等 为什么 Workbench 里面我们只能看到“demo”和“sys”这 2 个数据库呢？ 这是因为，Workbench 是图形化的管理工具，主要面向开发人 员，“demo”和“sys”这 2 个数据库已经够用了。如果有特殊需求，比如，需要监控 MySQL 数据库各项性能指标、直接操作 MySQL 数据库系统文件等，可以由 DBA 通过 SQL 语句，查看其它的系统数据库。 2、创建自己的数据库 create database 数据库名; #创建atguigudb数据库，该名称不能与已经存在的数据库重名。 create database atguigudb; 3、使用自己的数据库 use 数据库名; #使用atguigudb数据库 use atguigudb; 说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR 1046 (3D000): No database selected”（没有选择数据库） 使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另一个数据库操作，那么要重新use。 4、查看某个库的所有表格 show tables; #要求前面有use语句 show tables from 数据库名; 5、创建新的表格 create table 表名称( 字段名 数据类型, 字段名 数据类型 ); 说明：如果是最后一个字段，后面就用加逗号，因为逗号的作用是分割每个字段。 #创建学生表 create table student( id int, name varchar(20) #说名字最长不超过20个字符 ); 6、查看一个表的数据 select * from 数据库表名称; #查看学生表的数据 select * from student; 7、添加一条记录 insert into 表名称 values(值列表); #添加两条记录到student表中 insert into student values(1,'张三'); insert into student values(2,'李四'); 报错： mysql&gt; insert into student values(1,'张三'); ERROR 1366 (HY000): Incorrect string value: '\\xD5\\xC5\\xC8\\xFD' for column 'name' at row 1 mysql&gt; insert into student values(2,'李四'); ERROR 1366 (HY000): Incorrect string value: '\\xC0\\xEE\\xCB\\xC4' for column 'name' at row 1 mysql&gt; show create table student; 字符集的问题。 8、查看表的创建信息 show create table 表名称\\G #查看student表的详细创建信息 show create table student\\G #结果如下 *************************** 1. row *************************** Table: student Create Table: CREATE TABLE `student` ( `id` int(11) DEFAULT NULL, `name` varchar(20) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=latin1 1 row in set (0.00 sec) 上面的结果显示student的表格的默认字符集是“latin1”不支持中文。 9、查看数据库的创建信息 show create database 数据库名\\G #查看atguigudb数据库的详细创建信息 show create database atguigudb\\G #结果如下 *************************** 1. row *************************** Database: atguigudb Create Database: CREATE DATABASE `atguigudb` /*!40100 DEFAULT CHARACTER SET latin1 */ 1 row in set (0.00 sec) 上面的结果显示atguigudb数据库也不支持中文，字符集默认是latin1。 10、删除表格 drop table 表名称; #删除学生表 drop table student; 11、删除数据库 drop database 数据库名; #删除atguigudb数据库 drop database atguigudb; 4.2 MySQL的编码设置MySQL5.7中问题再现：命令行操作sql乱码问题 mysql&gt; INSERT INTO t_stu VALUES(1,'张三','男'); ERROR 1366 (HY000): Incorrect string value: '\\xD5\\xC5\\xC8\\xFD' for column 'sname' at row 1 问题解决 步骤1：查看编码命令 show variables like 'character_%'; show variables like 'collation_%'; 步骤2：修改mysql的数据目录下的my.ini配置文件 [mysql] #大概在63行左右，在其下添加 ... default-character-set=utf8 #默认字符集 [mysqld] # 大概在76行左右，在其下添加 ... character-set-server=utf8 collation-server=utf8_general_ci 注意：建议修改配置文件使用notepad++等高级文本编辑器，使用记事本等软件打开修改后可能会导致文件编码修改为“含BOM头”的编码，从而服务重启失败。 步骤3：重启服务 步骤4：查看编码命令 show variables like 'character_%'; show variables like 'collation_%'; 如果是以上配置就说明对了。接着我们就可以新创建数据库、新创建数据表，接着添加包含中文的数据了。 MySQL8.0中在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0开始，数据库的默认编码改为utf8mb4，从而避免了上述的乱码问题。 5. MySQL图形化管理工具MySQL图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：MySQL Workbench、phpMyAdmin、Navicat Preminum、MySQLDumper、SQLyog、dbeaver、MySQL ODBC Connector。 工具1. MySQL WorkbenchMySQL官方提供的图形化管理工具MySQL Workbench完全支持MySQL 5.0以上的版本。MySQL Workbench分为社区版和商业版，社区版完全免费，而商业版则是按年收费。 MySQL Workbench 为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库管理功能。它包含了用于创建复杂的数据建模ER模型，正向和逆向数据库工程，也可以用于执行通常需要花费大量时间的、难以变更和管理的文档任务。 下载地址：http://dev.mysql.com/downloads/workbench/。 使用： 首先，我们点击 Windows 左下角的“开始”按钮，如果你是 Win10 系统，可以直接看到所有程序。接着，找到“MySQL”，点开，找到“MySQL Workbench 8.0 CE”。点击打开 Workbench，如下图所示： 左下角有个本地连接，点击，录入 Root 的密码，登录本地 MySQL 数据库服务器，如下图所示： 这是一个图形化的界面，我来给你介绍下这个界面。 上方是菜单。左上方是导航栏，这里我们可以看到 MySQL 数据库服务器里面的数据 库，包括数据表、视图、存储过程和函数；左下方是信息栏，可以显示上方选中的数据 库、数据表等对象的信息。 中间上方是工作区，你可以在这里写 SQL 语句，点击上方菜单栏左边的第三个运行按 钮，就可以执行工作区的 SQL 语句了。 中间下方是输出区，用来显示 SQL 语句的运行情况，包括什么时间开始运行的、运行的 内容、运行的输出，以及所花费的时长等信息。 好了，下面我们就用 Workbench 实际创建一个数据库，并且导入一个 Excel 数据文件， 来生成一个数据表。数据表是存储数据的载体，有了数据表以后，我们就能对数据进行操作了。 工具2. NavicatNavicat MySQL是一个强大的MySQL数据库服务器管理和开发工具。它可以与任何3.21或以上版本的MySQL一起工作，支持触发器、存储过程、函数、事件、视图、管理用户等，对于新手来说易学易用。其精心设计的图形用户界面（GUI）可以让用户用一种安全简便的方式来快速方便地创建、组织、访问和共享信息。Navicat支持中文，有免费版本提供。下载地址：http://www.navicat.com/。 工具3. SQLyogSQLyog 是业界著名的 Webyog 公司出品的一款简洁高效、功能强大的图形化 MySQL 数据库管理工具。这款工具是使用C++语言开发的。该工具可以方便地创建数据库、表、视图和索引等，还可以方便地进行插入、更新和删除等操作，同时可以方便地进行数据库、数据表的备份和还原。该工具不仅可以通过SQL文件进行大量文件的导入和导出，还可以导入和导出XML、HTML和CSV等多种格式的数据。下载地址：http://www.webyog.com/，读者也可以搜索中文版的下载地址。 工具4：dbeaverDBeaver是一个通用的数据库管理工具和 SQL 客户端，支持所有流行的数据库：MySQL、PostgreSQL、SQLite、Oracle、DB2、SQL Server、 Sybase、MS Access、Teradata、 Firebird、Apache Hive、Phoenix、Presto等。DBeaver比大多数的SQL管理工具要轻量，而且支持中文界面。DBeaver社区版作为一个免费开源的产品，和其他类似的软件相比，在功能和易用性上都毫不逊色。 唯一需要注意是 DBeaver 是用Java编程语言开发的，所以需要拥有 JDK（Java Development ToolKit）环境。如果电脑上没有JDK，在选择安装DBeaver组件时，勾选“Include Java”即可。 下载地址：https://dbeaver.io/download/ 可能出现连接问题：有些图形界面工具，特别是旧版本的图形界面工具，在连接MySQL8时出现“Authentication plugin ‘caching_sha2_password’ cannot be loaded”错误。 出现这个原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则是caching_sha2_password。解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把MySQL8用户登录密码加密规则还原成mysql_native_password。 第二种解决方案如下，用命令行登录MySQL数据库之后，执行如下命令修改用户密码加密规则并更新用户密码，这里修改用户名为“root@localhost”的用户密码规则为“mysql_native_password”，密码值为“123456”，如图所示。 #使用mysql数据库 USE mysql; #修改'root'@'localhost'用户的密码规则和密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'abc123'; #刷新权限 FLUSH PRIVILEGES; 6. MySQL目录结构与源码6.1 主要目录结构 MySQL的目录结构 说明 bin目录 所有MySQL的可执行文件。如：mysql.exe MySQLInstanceConfig.exe 数据库的配置向导，在安装时出现的内容 data目录 系统数据库所在的目录 my.ini文件 MySQL的主要配置文件 c:\\ProgramData\\MySQL\\MySQL Server 8.0\\data\\ 用户创建的数据库所在的目录 6.2 MySQL 源代码获取首先，你要进入 MySQL下载界面。 这里你不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点击下载。 接下来，把下载下来的压缩文件解压，我们就得到了 MySQL 的源代码。 MySQL 是用 C++ 开发而成的，我简单介绍一下源代码的组成。 mysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码： sql 子目录是 MySQL 核心代码； libmysql 子目录是客户端程序 API； mysql-test 子目录是测试工具； mysys 子目录是操作系统相关函数和辅助函数； 源代码可以用记事本打开查看，如果你有 C++ 的开发环境，也可以在开发环境中打开查看。 如上图所示，源代码并不神秘，就是普通的 C++ 代码，跟你熟悉的一样，而且有很多注释，可以帮助你理解。阅读源代码就像在跟 MySQL 的开发人员对话一样，十分有趣。 7. 常见问题的解决(课外内容)问题1：root用户密码忘记，重置的操作1: 通过任务管理器或者服务管理，关掉mysqld(服务进程)2: 通过命令行+特殊参数开启mysqldmysqld –defaults-file=”D:\\ProgramFiles\\mysql\\MySQLServer5.7Data\\my.ini” –skip-grant-tables 3: 此时，mysqld服务进程已经打开。并且不需要权限检查4: mysql -uroot 无密码登陆服务器。另启动一个客户端进行5: 修改权限表（1） use mysql;（2）update user set authentication_string=password(‘新密码’) where user=’root’ and Host=’localhost’;（3）flush privileges;6: 通过任务管理器，关掉mysqld服务进程。7: 再次通过服务管理，打开mysql服务。8: 即可用修改后的新密码登陆。 问题2：mysql命令报“不是内部或外部命令”如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。如下： 问题3：错误ERROR ：没有选择数据库就操作表格和数据 ERROR 1046 (3D000): No database selected 解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作 解决方案二：就是所有的表对象前面都加上“数据库.” 问题4：命令行客户端的字符集问题mysql&gt; INSERT INTO t_stu VALUES(1,'张三','男'); ERROR 1366 (HY000): Incorrect string value: '\\xD5\\xC5\\xC8\\xFD' for column 'sname' at row 1 原因：服务器端认为你的客户端的字符集是utf-8，而实际上你的客户端的字符集是GBK。 查看所有字符集：SHOW VARIABLES LIKE ‘character_set_%’; 解决方案，设置当前连接的客户端字符集 “SET NAMES GBK;” 问题5：修改数据库和表的字符编码修改编码： （1)先停止服务，（2）修改my.ini文件（3）重新启动服务 说明： 如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用alter语句修改编码。 mysql&gt; create database 0728db charset Latin1; Query OK, 1 row affected (0.00 sec) mysql&gt; use 0728db; Database changed mysql&gt; create table student (id int , name varchar(20)) charset Latin1; Query OK, 0 rows affected (0.02 sec) mysql&gt; show create table student\\G *************************** 1. row *************************** Table: student Create Table: CREATE TABLE `student` ( `id` int(11) NOT NULL, `name` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 1 row in set (0.00 sec) mysql&gt; alter table student charset utf8; #修改表字符编码为UTF8 Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; show create table student\\G *************************** 1. row *************************** Table: student Create Table: CREATE TABLE `student` ( `id` int(11) NOT NULL, `name` varchar(20) CHARACTER SET latin1 DEFAULT NULL, #字段仍然是latin1编码 PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 1 row in set (0.00 sec) mysql&gt; alter table student modify name varchar(20) charset utf8; #修改字段字符编码为UTF8 Query OK, 0 rows affected (0.05 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; show create table student\\G *************************** 1. row *************************** Table: student Create Table: CREATE TABLE `student` ( `id` int(11) NOT NULL, `name` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 1 row in set (0.00 sec) mysql&gt; show create database 0728db;; +--------+-----------------------------------------------------------------+ |Database| Create Database | +------+-------------------------------------------------------------------+ |0728db| CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET latin1 */ | +------+-------------------------------------------------------------------+ 1 row in set (0.00 sec) mysql&gt; alter database 0728db charset utf8; #修改数据库的字符编码为utf8 Query OK, 1 row affected (0.00 sec) mysql&gt; show create database 0728db; +--------+-----------------------------------------------------------------+ |Database| Create Database | +--------+-----------------------------------------------------------------+ | 0728db | CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET utf8 */ | +--------+-----------------------------------------------------------------+ 1 row in set (0.00 sec)","categories":[{"name":"Mysql篇","slug":"Mysql篇","permalink":"https://bowonqin.github.io/categories/Mysql%E7%AF%87/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://bowonqin.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://bowonqin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"qxd"},{"title":"Mysql(基本的SELECT语句)","slug":"mysql/第03章-基本的SELECT语句","date":"2021-12-20T05:38:51.000Z","updated":"2021-12-20T09:00:11.923Z","comments":true,"path":"posts/mysql3.html","link":"","permalink":"https://bowonqin.github.io/posts/mysql3.html","excerpt":"","text":"第03章_基本的SELECT语句康师傅（宋红康老师）听课笔记 BILIBILI听课网址：[宋红康]MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili 1. SQL概述1.1 SQL背景知识 1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。 45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。 不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。 SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道，由IBM上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有SQL-86，SQL-89，SQL-92，SQL-99等标准。 SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。 不同的数据库生产厂商都支持SQL语句，但都有特有内容。 1.2 SQL语言排行榜自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。 1.3 SQL 分类SQL语言在功能上主要分为如下3大类： DDL（Data Definition Languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 主要的语句关键字包括CREATE、DROP、ALTER等。 DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。 主要的语句关键字包括INSERT、DELETE、UPDATE、SELECT等。 SELECT是SQL语言的基础，最为重要。 DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。 主要的语句关键字包括GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT等。 因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。 还有单独将COMMIT、ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语言）。 2. SQL语言的规则与规范2.1 基本规则 SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进 每条命令以 ; 或 \\g 或 \\G 结束 关键字不能被缩写也不能分行 关于标点符号 必须保证所有的()、单引号、双引号是成对结束的 必须使用英文状态下的半角输入方式 字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示 列的别名，尽量使用双引号（” “），而且不建议省略as 2.2 SQL大小写规范 （建议遵守） MySQL 在 Windows 环境下是大小写不敏感的 MySQL 在 Linux 环境下是大小写敏感的 数据库名、表名、表的别名、变量名是严格区分大小写的 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。 推荐采用统一的书写规范： 数据库名、表名、表别名、字段名、字段别名等都小写 SQL 关键字、函数名、绑定变量等都大写 2.3 注 释可以使用如下格式的注释结构 单行注释：#注释文字(MySQL特有的方式) 单行注释：-- 注释文字(--后面必须包含一个空格。) 多行注释：/* 注释文字 */ 2.4 命名规则（暂时了解） 数据库、表名不得超过30个字符，变量名限制为29个 必须只能包含 A–Z, a–z, 0–9, _共63个字符 数据库名、表名、字段名等对象名中间不要包含空格 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了 举例： #以下两句是一样的，不区分大小写 show databases; SHOW DATABASES; #创建表格 #create table student info(...); #表名错误，因为表名有空格 create table student_info(...); #其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了 CREATE TABLE `order`( id INT, lname VARCHAR(20) ); select id as \"编号\", `name` as \"姓名\" from t_stu; #起别名时，as都可以省略 select id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略\"\" select id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略\"\" 2.5 数据导入指令在命令行客户端登录mysql，使用source指令导入 mysql&gt; source d:\\mysqldb.sql mysql&gt; desc employees; +----------------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------------+-------------+------+-----+---------+-------+ | employee_id | int(6) | NO | PRI | 0 | | | first_name | varchar(20) | YES | | NULL | | | last_name | varchar(25) | NO | | NULL | | | email | varchar(25) | NO | UNI | NULL | | | phone_number | varchar(20) | YES | | NULL | | | hire_date | date | NO | | NULL | | | job_id | varchar(10) | NO | MUL | NULL | | | salary | double(8,2) | YES | | NULL | | | commission_pct | double(2,2) | YES | | NULL | | | manager_id | int(6) | YES | MUL | NULL | | | department_id | int(4) | YES | MUL | NULL | | +----------------+-------------+------+-----+---------+-------+ 11 rows in set (0.00 sec) 3. 基本的SELECT语句3.0 SELECT…SELECT 1; #没有任何子句 SELECT 9/2; #没有任何子句 3.1 SELECT … FROM 语法： SELECT 标识选择哪些列 FROM 标识从哪个表中选择 选择全部列： SELECT * FROM departments; 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。 在生产环境下，不推荐你直接使用SELECT *进行查询。 选择特定的列： SELECT department_id, location_id FROM departments; MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。 3.2 列的别名 重命名一个列 便于计算 紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。 AS 可以省略 建议别名简短，见名知意 举例 SELECT last_name AS name, commission_pct comm FROM employees; SELECT last_name \"Name\", salary*12 \"Annual Salary\" FROM employees; 3.3 去除重复行默认情况下，查询会返回全部行，包括重复行。 SELECT department_id FROM employees; 在SELECT语句中使用关键字DISTINCT去除重复行 SELECT DISTINCT department_id FROM employees; 针对于： SELECT DISTINCT department_id,salary FROM employees; 这里有两点需要注意： DISTINCT 需要放到所有列名的前面，如果写成SELECT salary, DISTINCT department_id FROM employees会报错。 DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写DISTINCT department_id即可，后面不需要再加其他的列名了。 3.4 空值参与运算 所有运算符或列值遇到null值，运算的结果都为null SELECT employee_id,salary,commission_pct, 12 * salary * (1 + commission_pct) \"annual_sal\" FROM employees; 这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。 3.5 着重号 错误的 mysql&gt; SELECT * FROM ORDER; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'ORDER' at line 1 正确的 mysql&gt; SELECT * FROM `ORDER`; +----------+------------+ | order_id | order_name | +----------+------------+ | 1 | shkstart | | 2 | tomcat | | 3 | dubbo | +----------+------------+ 3 rows in set (0.00 sec) mysql&gt; SELECT * FROM `order`; +----------+------------+ | order_id | order_name | +----------+------------+ | 1 | shkstart | | 2 | tomcat | | 3 | dubbo | +----------+------------+ 3 rows in set (0.00 sec) 结论 我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来。 3.6 5、查询常数SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。 你可能会问为什么我们还要对常数进行查询呢？ SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。 比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段corporation，这个字段固定值为“尚硅谷”，可以这样写： SELECT '尚硅谷' as corporation, last_name FROM employees; 4. 显示表结构使用DESCRIBE 或 DESC 命令，表示表结构。 DESCRIBE employees; 或 DESC employees; mysql&gt; desc employees; +----------------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------------+-------------+------+-----+---------+-------+ | employee_id | int(6) | NO | PRI | 0 | | | first_name | varchar(20) | YES | | NULL | | | last_name | varchar(25) | NO | | NULL | | | email | varchar(25) | NO | UNI | NULL | | | phone_number | varchar(20) | YES | | NULL | | | hire_date | date | NO | | NULL | | | job_id | varchar(10) | NO | MUL | NULL | | | salary | double(8,2) | YES | | NULL | | | commission_pct | double(2,2) | YES | | NULL | | | manager_id | int(6) | YES | MUL | NULL | | | department_id | int(4) | YES | MUL | NULL | | +----------------+-------------+------+-----+---------+-------+ 11 rows in set (0.00 sec) 其中，各个字段的含义分别解释如下： Field：表示字段名称。 Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。 Null：表示该列是否可以存储NULL值。 Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，那么值是多少。 Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。 5. 过滤数据 背景： 语法： SELECT 字段1,字段2 FROM 表名 WHERE 过滤条件 使用WHERE 子句，将不满足条件的行过滤掉 WHERE子句紧随 FROM子句 举例 SELECT employee_id, last_name, job_id, department_id FROM employees WHERE department_id = 90 ;","categories":[{"name":"Mysql篇","slug":"Mysql篇","permalink":"https://bowonqin.github.io/categories/Mysql%E7%AF%87/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://bowonqin.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://bowonqin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"qxd"},{"title":"Mysql(第04章_运算符)","slug":"mysql/第04章-运算符","date":"2021-12-20T05:38:51.000Z","updated":"2021-12-20T12:43:52.592Z","comments":true,"path":"posts/mysql4.html","link":"","permalink":"https://bowonqin.github.io/posts/mysql4.html","excerpt":"","text":"第04章_运算符康师傅（宋红康老师）听课笔记 BILIBILI听课网址：[宋红康]MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili 1. 算术运算符算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。 1．加法与减法运算符 mysql&gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual; +-----+---------+---------+----------+--------------+------------+------------+ | 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 | +-----+---------+---------+----------+--------------+------------+------------+ | 100 | 100 | 100 | 150 | 120 | 135.5 | 64.5 | +-----+---------+---------+----------+--------------+------------+------------+ 1 row in set (0.00 sec) 由运算结果可以得出如下结论： 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数； 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数； 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的； 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现） 2．乘法与除法运算符 mysql&gt; SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual; +-----+---------+-----------+-----------+---------+-----------------+---------+-----------+ | 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3 | 100 DIV 0 | +-----+---------+-----------+-----------+---------+-----------------+---------+-----------+ | 100 | 100 | 100.0 | 100.0000 | 50.0000 | 105.0000 | 33.3333 | NULL | +-----+---------+-----------+-----------+---------+-----------------+---------+-----------+ 1 row in set (0.00 sec) #计算出员工的年基本工资 SELECT employee_id,salary,salary * 12 annual_sal FROM employees; 由运算结果可以得出如下结论： 一个数乘以整数1和除以整数1后仍得原数； 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等； 一个数除以整数后，不管是否能除尽，结果都为一个浮点数； 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位； 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。 3．求模（求余）运算符将t22表中的字段i对3和5进行求模（求余）运算。 mysql&gt; SELECT 12 % 3, 12 MOD 5 FROM dual; +--------+----------+ | 12 % 3 | 12 MOD 5 | +--------+----------+ | 0 | 2 | +--------+----------+ 1 row in set (0.00 sec) #筛选出employee_id是偶数的员工 SELECT * FROM employees WHERE employee_id MOD 2 = 0; 可以看到，100对3求模后的结果为3，对5求模后的结果为0。 2. 比较运算符比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。 比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。 1．等号运算符 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。 在使用等号运算符时，遵循如下规则： 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。 对比：SQL中赋值符号使用 := mysql&gt; SELECT 1 = 1, 1 = '1', 1 = 0, 'a' = 'a', (5 + 3) = (2 + 6), '' = NULL , NULL = NULL; +-------+---------+-------+-----------+-------------------+-----------+-------------+ | 1 = 1 | 1 = '1' | 1 = 0 | 'a' = 'a' | (5 + 3) = (2 + 6) | '' = NULL | NULL = NULL | +-------+---------+-------+-----------+-------------------+-----------+-------------+ | 1 | 1 | 0 | 1 | 1 | NULL | NULL | +-------+---------+-------+-----------+-------------------+-----------+-------------+ 1 row in set (0.00 sec) mysql&gt; SELECT 1 = 2, 0 = 'abc', 1 = 'abc' FROM dual; +-------+-----------+-----------+ | 1 = 2 | 0 = 'abc' | 1 = 'abc' | +-------+-----------+-----------+ | 0 | 1 | 0 | +-------+-----------+-----------+ 1 row in set, 2 warnings (0.00 sec) #查询salary=10000，注意在Java中比较是== SELECT employee_id,salary FROM employees WHERE salary = 10000; 2．安全等于运算符安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，唯一的区别是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。 mysql&gt; SELECT 1 &lt;=&gt; '1', 1 &lt;=&gt; 0, 'a' &lt;=&gt; 'a', (5 + 3) &lt;=&gt; (2 + 6), '' &lt;=&gt; NULL,NULL &lt;=&gt; NULL FROM dual; +-----------+---------+-------------+---------------------+-------------+---------------+ | 1 &lt;=&gt; '1' | 1 &lt;=&gt; 0 | 'a' &lt;=&gt; 'a' | (5 + 3) &lt;=&gt; (2 + 6) | '' &lt;=&gt; NULL | NULL &lt;=&gt; NULL | +-----------+---------+-------------+---------------------+-------------+---------------+ | 1 | 0 | 1 | 1 | 0 | 1 | +-----------+---------+-------------+---------------------+-------------+---------------+ 1 row in set (0.00 sec) #查询commission_pct等于0.40 SELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40; SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; 0.40; #如果把0.40改成 NULL 呢？ 可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同。 3．不等于运算符不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。SQL语句示例如下： mysql&gt; SELECT 1 &lt;&gt; 1, 1 != 2, 'a' != 'b', (3+4) &lt;&gt; (2+6), 'a' != NULL, NULL &lt;&gt; NULL; +--------+--------+------------+----------------+-------------+--------------+ | 1 &lt;&gt; 1 | 1 != 2 | 'a' != 'b' | (3+4) &lt;&gt; (2+6) | 'a' != NULL | NULL &lt;&gt; NULL | +--------+--------+------------+----------------+-------------+--------------+ | 0 | 1 | 1 | 1 | NULL | NULL | +--------+--------+------------+----------------+-------------+--------------+ 1 row in set (0.00 sec) 此外，还有非符号类型的运算符： 4. 空运算符空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。SQL语句示例如下： mysql&gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL('a'), 1 IS NULL; +--------------+--------------+-------------+-----------+ | NULL IS NULL | ISNULL(NULL) | ISNULL('a') | 1 IS NULL | +--------------+--------------+-------------+-----------+ | 1 | 1 | 0 | 0 | +--------------+--------------+-------------+-----------+ 1 row in set (0.00 sec) #查询commission_pct等于NULL。比较如下的四种写法 SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL; SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL; SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct); SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL; SELECT last_name, manager_id FROM employees WHERE manager_id IS NULL; 5. 非空运算符非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。SQL语句示例如下： mysql&gt; SELECT NULL IS NOT NULL, 'a' IS NOT NULL, 1 IS NOT NULL; +------------------+-----------------+---------------+ | NULL IS NOT NULL | 'a' IS NOT NULL | 1 IS NOT NULL | +------------------+-----------------+---------------+ | 0 | 1 | 1 | +------------------+-----------------+---------------+ 1 row in set (0.01 sec) #查询commission_pct不等于NULL SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL; SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct &lt;=&gt; NULL; SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct); 6. 最小值运算符语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。 mysql&gt; SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2); +---------------+--------------------+-----------------+ | LEAST (1,0,2) | LEAST('b','a','c') | LEAST(1,NULL,2) | +---------------+--------------------+-----------------+ | 0 | a | NULL | +---------------+--------------------+-----------------+ 1 row in set (0.00 sec) 由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。 7. 最大值运算符语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。 mysql&gt; SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2); +-----------------+-----------------------+--------------------+ | GREATEST(1,0,2) | GREATEST('b','a','c') | GREATEST(1,NULL,2) | +-----------------+-----------------------+--------------------+ | 2 | c | NULL | +-----------------+-----------------------+--------------------+ 1 row in set (0.00 sec) 由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。 8. BETWEEN AND运算符BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。 mysql&gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, 'b' BETWEEN 'a' AND 'c'; +-------------------+----------------------+-------------------------+ | 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | 'b' BETWEEN 'a' AND 'c' | +-------------------+----------------------+-------------------------+ | 1 | 0 | 1 | +-------------------+----------------------+-------------------------+ 1 row in set (0.00 sec) SELECT last_name, salary FROM employees WHERE salary BETWEEN 2500 AND 3500; 9. IN运算符IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。 mysql&gt; SELECT 'a' IN ('a','b','c'), 1 IN (2,3), NULL IN ('a','b'), 'a' IN ('a', NULL); +----------------------+------------+-------------------+--------------------+ | 'a' IN ('a','b','c') | 1 IN (2,3) | NULL IN ('a','b') | 'a' IN ('a', NULL) | +----------------------+------------+-------------------+--------------------+ | 1 | 0 | NULL | 1 | +----------------------+------------+-------------------+--------------------+ 1 row in set (0.00 sec) SELECT employee_id, last_name, salary, manager_id FROM employees WHERE manager_id IN (100, 101, 201); 10. NOT IN运算符NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。 mysql&gt; SELECT 'a' NOT IN ('a','b','c'), 1 NOT IN (2,3); +--------------------------+----------------+ | 'a' NOT IN ('a','b','c') | 1 NOT IN (2,3) | +--------------------------+----------------+ | 0 | 1 | +--------------------------+----------------+ 1 row in set (0.00 sec) 11. LIKE运算符LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。 LIKE运算符通常使用如下通配符： “%”：匹配0个或多个字符。 “_”：只能匹配一个字符。 SQL语句示例如下： mysql&gt; SELECT NULL LIKE 'abc', 'abc' LIKE NULL; +-----------------+-----------------+ | NULL LIKE 'abc' | 'abc' LIKE NULL | +-----------------+-----------------+ | NULL | NULL | +-----------------+-----------------+ 1 row in set (0.00 sec) SELECT first_name FROM employees WHERE first_name LIKE 'S%'; SELECT last_name FROM employees WHERE last_name LIKE '_o%'; ESCAPE 回避特殊符号的：使用转义符。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。 SELECT job_id FROM jobs WHERE job_id LIKE ‘IT\\_%‘; 如果使用\\表示转义，要省略ESCAPE。如果不是\\，则要加上ESCAPE。 SELECT job_id FROM jobs WHERE job_id LIKE ‘IT$_%‘ escape ‘$‘; 12. REGEXP运算符 REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。 REGEXP运算符在进行匹配时，常用的有下面几种通配符： （1）‘^’匹配以该字符后面的字符开头的字符串。 （2）‘$’匹配以该字符前面的字符结尾的字符串。 （3）‘.’匹配任何一个单字符。 （4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。 （5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。 SQL语句示例如下： mysql&gt; SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk'; +------------------------+------------------------+-------------------------+ | 'shkstart' REGEXP '^s' | 'shkstart' REGEXP 't$' | 'shkstart' REGEXP 'hk' | +------------------------+------------------------+-------------------------+ | 1 | 1 | 1 | +------------------------+------------------------+-------------------------+ 1 row in set (0.01 sec) mysql&gt; SELECT 'atguigu' REGEXP 'gu.gu', 'atguigu' REGEXP '[ab]'; +--------------------------+-------------------------+ | 'atguigu' REGEXP 'gu.gu' | 'atguigu' REGEXP '[ab]' | +--------------------------+-------------------------+ | 1 | 1 | +--------------------------+-------------------------+ 1 row in set (0.00 sec) 3. 逻辑运算符逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。 MySQL中支持4种逻辑运算符如下： 1．逻辑非运算符逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。 mysql&gt; SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL; +-------+-------+----------+--------+----------+ | NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL | +-------+-------+----------+--------+----------+ | 0 | 1 | 0 | 1 | NULL | +-------+-------+----------+--------+----------+ 1 row in set, 1 warning (0.00 sec) SELECT last_name, job_id FROM employees WHERE job_id NOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP'); 2．逻辑与运算符逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。 mysql&gt; SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL; +----------+---------+------------+------------+ | 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL | +----------+---------+------------+------------+ | 1 | 0 | 0 | NULL | +----------+---------+------------+------------+ 1 row in set (0.00 sec) SELECT employee_id, last_name, job_id, salary FROM employees WHERE salary &gt;=10000 AND job_id LIKE '%MAN%'; 3．逻辑或运算符逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。 mysql&gt; SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL; +---------+--------+-----------+-----------+--------------+ | 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL | +---------+--------+-----------+-----------+--------------+ | 1 | 1 | 1 | NULL | NULL | +---------+--------+-----------+-----------+--------------+ 1 row in set, 2 warnings (0.00 sec) #查询基本薪资不在9000-12000之间的员工编号和基本薪资 SELECT employee_id,salary FROM employees WHERE NOT (salary &gt;= 9000 AND salary &lt;= 12000); SELECT employee_id,salary FROM employees WHERE salary &lt;9000 OR salary &gt; 12000; SELECT employee_id,salary FROM employees WHERE salary NOT BETWEEN 9000 AND 12000; SELECT employee_id, last_name, job_id, salary FROM employees WHERE salary &gt;= 10000 OR job_id LIKE '%MAN%'; 注意： OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。 4．逻辑异或运算符逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。 mysql&gt; SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0; +----------+---------+---------+------------+---------------+---------------+ | 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 | +----------+---------+---------+------------+---------------+---------------+ | 0 | 1 | 0 | NULL | 1 | 0 | +----------+---------+---------+------------+---------------+---------------+ 1 row in set (0.00 sec) select last_name,department_id,salary from employees where department_id in (10,20) XOR salary &gt; 8000; 4. 位运算符位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。 MySQL支持的位运算符如下： 1．按位与运算符按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。 mysql&gt; SELECT 1 &amp; 10, 20 &amp; 30; +--------+---------+ | 1 &amp; 10 | 20 &amp; 30 | +--------+---------+ | 0 | 20 | +--------+---------+ 1 row in set (0.00 sec) 1的二进制数为0001，10的二进制数为1010，所以1 &amp; 10的结果为0000，对应的十进制数为0。20的二进制数为10100，30的二进制数为11110，所以20 &amp; 30的结果为10100，对应的十进制数为20。 2. 按位或运算符按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。 mysql&gt; SELECT 1 | 10, 20 | 30; +--------+---------+ | 1 | 10 | 20 | 30 | +--------+---------+ | 11 | 30 | +--------+---------+ 1 row in set (0.00 sec) 1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。 3. 按位异或运算符按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。 mysql&gt; SELECT 1 ^ 10, 20 ^ 30; +--------+---------+ | 1 ^ 10 | 20 ^ 30 | +--------+---------+ | 11 | 10 | +--------+---------+ 1 row in set (0.00 sec) 1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。 再举例： mysql&gt; SELECT 12 &amp; 5, 12 | 5,12 ^ 5 FROM DUAL; +--------+--------+--------+ | 12 &amp; 5 | 12 | 5 | 12 ^ 5 | +--------+--------+--------+ | 4 | 13 | 9 | +--------+--------+--------+ 1 row in set (0.00 sec) 4. 按位取反运算符按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。 mysql&gt; SELECT 10 &amp; ~1; +---------+ | 10 &amp; ~1 | +---------+ | 10 | +---------+ 1 row in set (0.00 sec) 由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以10 &amp; ~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。 5. 按位右移运算符按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。 mysql&gt; SELECT 1 &gt;&gt; 2, 4 &gt;&gt; 2; +--------+--------+ | 1 &gt;&gt; 2 | 4 &gt;&gt; 2 | +--------+--------+ | 0 | 1 | +--------+--------+ 1 row in set (0.00 sec) 1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2位为0000 0001，对应的十进制数为1。 6. 按位左移运算符按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。 mysql&gt; SELECT 1 &lt;&lt; 2, 4 &lt;&lt; 2; +--------+--------+ | 1 &lt;&lt; 2 | 4 &lt;&lt; 2 | +--------+--------+ | 4 | 16 | +--------+--------+ 1 row in set (0.00 sec) 1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16。 5. 运算符的优先级 数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。 拓展：使用正则表达式查询正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。 MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。 1. 查询以特定字符或字符串开头的记录字符‘^’匹配以特定字符或者字符串开头的文本。 在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '^b'; 2. 查询以特定字符或字符串结尾的记录字符‘$’匹配以特定字符或者字符串结尾的文本。 在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'y$'; 3. 用符号”.”来替代字符串中的任意一个字符字符‘.’匹配任意一个字符。在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'a.g'; *4. 使用”“和”+”来匹配多个字符**星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。 在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '^ba*'; 在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '^ba+'; 5. 匹配指定字符串正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。 在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'on'; 在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'on|ap'; 之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。 在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name like 'on'; Empty set(0.00 sec) 6. 匹配指定字符中的任意一个方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。 在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '[ot]'; 在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP '[456]'; 7. 匹配指定字符以外的字符“[^字符集合]”匹配不在指定集合中的任何字符。 在fruits表中，查询f_id字段中包含字母ae和数字12以外字符的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP '[^a-e1-2]'; 8. 使用{n,}或者{n,m}来指定字符串连续出现的次数“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。 在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'x{2,}'; 在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下： mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'ba{1,3}';","categories":[{"name":"Mysql篇","slug":"Mysql篇","permalink":"https://bowonqin.github.io/categories/Mysql%E7%AF%87/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://bowonqin.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://bowonqin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"qxd"},{"title":"Mybatis(高级)","slug":"mabatis/Mybatis(高级)","date":"2021-12-18T16:00:00.000Z","updated":"2021-12-20T05:41:38.590Z","comments":true,"path":"posts/333222.html","link":"","permalink":"https://bowonqin.github.io/posts/333222.html","excerpt":"","text":"MyBatis缓存一级缓存1） 在一个sqlSession中，对User表根据id进行两次查询，查看他们发出sql语句的情况 public class CacheTest { private IUserMapper userMapper; private SqlSession sqlSession; @BeforeEach public void before() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); sqlSession = sqlSessionFactory.openSession(); userMapper = sqlSession.getMapper(IUserMapper.class); } @Test public void firstLevelCache(){ User user1 = userMapper.findById(1); User user2 = userMapper.findById(1); System.out.println(user1 == user2); sqlSession.close(); } } 查看控制台输出情况 ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, liutao, null, null &lt;== Total: 1 true 就是在第一次查询时，发出了上面的sql语句，然后在第二次查询时没有发出查询的sql语句。 2） 同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作 @Test public void firstLevelCache(){ User user1 = userMapper.findById(1); // update User user = new User(); user.setId(1); user.setUsername(\"liutao\"); user.setPassword(user1.getPassword()); user.setBirthday(user1.getBirthday()); userMapper.updateUser(user); sqlSession.commit(); User user2 = userMapper.findById(1); System.out.println(user1 == user2); } 查看控制台输出情况 ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, sss, 123, 2019-12-12 &lt;== Total: 1 ==&gt; Preparing: update user set username=?,password=?,birthday=? where id=? ==&gt; Parameters: liutao(String), 123(String), 2019-12-12(String), 1(Integer) &lt;== Updates: 1 Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@47f9738] ==&gt; Preparing: select * from user where id=? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, username, password, birthday &lt;== Row: 1, liutao, 123, 2019-12-12 &lt;== Total: 1 false 总结 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从 数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。 如果中间sqlSession去执行commit操作（执行插入、更新、删除）或者手动关闭缓存，则会清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直 接从缓存中获取用户信息。 一级缓存原理探究和源码分析一级缓存到底是什么？一级缓存什么时候被创建、一级缓存的工作流程是怎样的？相信你现在应该会有这几个疑问，那么我们本节就来研究一下一级缓存的本质。 大家可以这样想，上面我们一直提到一级缓存，那么提到一级缓存就绕不开SqlSession,所以索性我们就直接从SqlSession，看看有没有创建缓存或者与缓存有关的属性或者方法。 调研了一圈，发现上述所有方法中，好像只有clearCache()和缓存沾点关系，那么就直接从这个方 法入手吧，分析源码时，我们要看它(此类)是谁，它的父类和子类分别又是谁，对如上关系了解了，你才 会对这个类有更深的认识，分析了一圈，你可能会得到如下这个流程图。 再深入分析，流程走到Perpetualcache中的clear()方法之后，会调用其cache.clear()方法，那 么这个cache是什么东西呢？点进去发现，cache其实就是private Map cache = new HashMap()；也就是一个Map，所以说cache.clear()其实就是map.clear()，也就是说缓存其实就是本地存放的一个map对象，每一个SqISession都会存放一个map对象的引用，那么这个cache是何 时创建的呢？ 你觉得最有可能创建缓存的地方是哪里呢？我觉得是Executor，为什么这么认为？因为Executor是 执行器，用来执行SQL请求，而且清除缓存的方法也在Executor中执行，所以很可能缓存的创建也很 有可能在Executor中，看了一圈发现Executor中有一个createCacheKey方法，这个方法很像是创 建缓存的方法啊，跟进去看看，你发现createCacheKey方法是由BaseExecutor执行的，代码如下 public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) { CacheKey cacheKey = new CacheKey(); //MappedStatement 的 id // id就是Sql语句的所在位置包名+类名+ SQL名称 cacheKey.update(ms.getId()); // offset 就是 0 cacheKey.update(rowBounds.getOffset()); // limit 就是 Integer.MAXVALUE cacheKey.update(rowBounds.getLimit()); //具体的SQL语句 cacheKey.update(boundSql.getSql()); //后面是update 了 sql中带的参数 cacheKey.update(value); cacheKey.update(this.configuration.getEnvironment().getId()); } 创建缓存key会经过一系列的update方法，udate方法由一个CacheKey这个对象来执行的，这个update方法最终由updateList的list来把五个值存进去. 那么我们回归正题，那么创建完缓存之后该用在何处呢？总不会凭空创建一个缓存不使用吧？绝对不会的，经过我们对一级缓存的探究之后，我们发现一级缓存更多是用于查询操作，毕竟一级缓存也叫做查询缓存吧，为什么叫查询缓存我们一会儿说。我们先来看一下这个缓存到底用在哪了，我们跟踪到query方法如下： @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException { BoundSql boundSql = ms.getBoundSql(parameter); //创建缓存 CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql); } @SuppressWarnings(\"unchecked\") @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { ... list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) { //这个主要是处理存储过程用的。 handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); } else { list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); } ... } // queryFromDatabase 方法 private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { List&lt;E&gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); try {list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); } finally { localCache.removeObject(key); } localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) { localOutputParameterCache.putObject(key, parameter); } return list; } 如果查不到的话，就从数据库查，在queryFromDatabase中，会对localcache进行写入。 localcache对象的put方法最终交给Map进行存放。 private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); @Override public void putObject(Object key, Object value) { cache.put(key, value); } 二级缓存二级缓存的原理和一级缓存原理一样，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去缓存中取。但是一级缓存是基于sqlSession的，而二级缓存是基于mapper文件的namespace的，也就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果两个mapper的namespace 相同，即使是两个mapper,那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域 中。 ​ 如何使用二级缓存 和一级缓存默认开启不一样，二级缓存需要我们手动开启首先在全局配置文件sqlMapConfig.xml文件中加入如下代码: &lt;!--开启二级缓存--&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; 其次在UserMapper.xml文件中开启缓存 &lt;!--开启二级缓存--&gt; &lt;cache&gt;&lt;/cache&gt; 或者在UserMapper接口中添加注解 @CacheNamespace(implementation = PerpetualCache.class) 我们可以看到mapper.xml文件中就这么一个空标签，其实这里可以配置,PerpetualCache这个类是mybatis默认实现缓存功能的类。我们不写type就使用mybatis默认的缓存，也可以去实现Cache接口来自定义缓存。","categories":[{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"}],"author":"qxd"},{"title":"Mysql(数据库概述)","slug":"mysql/第01章_数据库概述","date":"2021-12-18T16:00:00.000Z","updated":"2021-12-20T04:58:42.844Z","comments":true,"path":"posts/18293.html","link":"","permalink":"https://bowonqin.github.io/posts/18293.html","excerpt":"","text":"第01章_数据库概述康师傅（宋红康老师）听课笔记 BILIBILI听课网址：[宋红康]MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili 1. 为什么要使用数据库 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 生活中的例子： 2. 数据库与数据库管理系统2.1 数据库的相关概念 DB：数据库（Database） 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。 DBMS：数据库管理系统（Database Management System） 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。 SQL：结构化查询语言（Structured Query Language） 专门用来与数据库通信的语言。 2.2 数据库与数据库管理系统的关系数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。 数据库管理系统、数据库和表的关系如图所示： 2.3 常见的数据库管理系统排名(DBMS)目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。以下是2021年DB-Engines Ranking 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:https://db-engines.com/en/ranking） 对应的走势图：（https://db-engines.com/en/ranking_trend） 2.4 常见的数据库介绍Oracle 1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。 2007年，总计85亿美金收购BEA Systems。 2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。 2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。 如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。 SQL Server SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。 DB2 IBM公司的数据库产品,收费的。常应用在银行系统中。 PostgreSQL PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。 SyBase 已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。 SQLite 嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。 informix IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。 3. MySQL介绍 3.1 概述 MySQL是一个开放源代码的关系型数据库管理系统，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。 2008被Sun收购（10亿美金），2009年Sun被Oracle收购。MariaDB应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB） MySQL6.x 版本之后分为社区版和商业版。 MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL是开源的，所以你不需要支付额外的费用。 MySQL是可以定制的，采用了GPL（GNU General Public License）协议，你可以修改源码来开发自己的MySQL系统。 MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。 MySQL使用标准的SQL数据语言形式。 MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。 3.2 MySQL发展史重大事件MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。 1.4 关于MySQL 8.0MySQL从5.7版本直接跳跃发布了8.0版本，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。 1.5 Why choose MySQL? 为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点： 开放源代码，使用成本低。 性能卓越，服务稳定。 软件体积小，使用简单，并且易于维护。 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。 许多互联网公司在用，经过了时间的验证。 1.6 Oracle vs MySQLOracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。 MySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。 4. RDBMS 与 非RDBMS从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。 4.1 关系型数据库(RDBMS)4.1.1 实质 这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。 关系型数据库以行(row)和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table)，一组表组成了一个库(database)。 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。 SQL 就是关系型数据库的查询语言。 4.1.2 优势 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。 4.2 非关系型数据库(非RDBMS)4.2.1 介绍非关系型数据库，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。同时，通过减少不常用的功能，进一步提高性能。 目前基本上大部分主流的非关系型数据库都是免费的。 4.2.2 有哪些非关系型数据库相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。 键值型数据库 键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。 键值型数据库典型的使用场景是作为内存缓存。Redis 是最流行的键值型数据库。 文档型数据库 此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。 搜索引擎数据库 虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。 典型产品：Solr、Elasticsearch、Splunk 等。 列式数据库 列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。 图形数据库 图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。 图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。 4.2.3 NoSQL的演变由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 NoSQL 功能的演变： 1970：NoSQL = We have no SQL 1980：NoSQL = Know SQL 2000：NoSQL = No SQL! 2005：NoSQL = Not only SQL 2013：NoSQL = No, SQL! NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。 4.3 小结NoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有必要的。整套课程将围绕 SQL 展开。 5. 关系型数据库设计规则 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。 将数据放到表中，表再放到库中。 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。 5.1 表、记录、字段 E-R（entity-relationship，实体-联系）模型中有三个主要概念是：实体集、属性、联系集。 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。 ORM思想 (Object Relational Mapping)体现： 数据库中的一个表 &lt;---&gt; Java或Python中的一个类 表中的一条数据 &lt;---&gt; 类中的一个对象（或实体） 表中的一个列 &lt;----&gt; 类中的一个字段、属性(field) 5.2 表的关联关系 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。 四种：一对一关联、一对多关联、多对多关联、自我引用 5.2.1 一对一关联（one-to-one） 在实际的开发中应用不多，因为一对一可以创建成一张表。 举例：设计学生表：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、… 拆为两个表：两个表的记录是一一对应关系。 基础信息表（常用信息）：学号、姓名、手机号码、班级、系别 档案信息表（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、… 两种建表原则： 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 外键是主键：主表的主键和从表的主键，形成主外键关系。 5.2.2 一对多关系（one-to-many） 常见实例场景：客户表和订单表，分类表和商品表，部门表和员工表。 举例： 员工表：编号、姓名、…、所属部门 部门表：编号、名称、简介 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键 5.2.3 多对多（many-to-many）要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。 举例1：学生-课程 学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…） 课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介…） 选课信息表：一个学生可以选多门课，一门课可以被多个学生选择 学号 课程编号 1 1001 2 1001 1 1002 举例2：产品-订单 “订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。 产品表：“产品”表中的每条记录表示一个产品。 订单表：“订单”表中的每条记录表示一个订单。 订单明细表：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。 举例3：用户-角色 多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。 5.3.4 自我引用(Self reference)","categories":[{"name":"Mysql篇","slug":"Mysql篇","permalink":"https://bowonqin.github.io/categories/Mysql%E7%AF%87/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://bowonqin.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://bowonqin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"qxd"},{"title":"牛客高频面试题","slug":"常见面试题总结/牛客100","date":"2021-12-16T16:00:00.000Z","updated":"2021-12-20T05:26:16.303Z","comments":true,"path":"posts/niuke100.html","link":"","permalink":"https://bowonqin.github.io/posts/niuke100.html","excerpt":"","text":"字符串搜索-BF和RK 给定两个字符串A、B，判断B在A中是否存在，存在返回A中的下标，不存在返回-1 例如： A：ABCABCABCCCAAA ​ B: BCCCA 返回值 6 java中的String.indexOf()方法可以实现 BF暴力算法逐字符地进行匹配（比较A[i]和B[j]）,如果当前字符匹配成功（A[i] == B[j]），就匹配下一个字符（++i,++j），如果失配，i回溯，j置为0（i = i-j+1,j=0） 时间复杂度为O(n*m)，与主串和模式串的长度正相关 // pat匹配串 // txt原串 int search(String pat, String txt) { if (pat == null || txt == null) { return -1; } int M = pat.length(); int N = txt.length(); for (int i = 0; i &lt; N - M; i++) { int j; for (j = 0; j &lt; M; j++) { if (pat.charAt(j) != txt.charAt(i + j)) { break; } } // pat全部匹配了 if (j == M) return i; } return -1; } RK算法：hash算法基于BF进行优化，将A字符按顺序和B串的长度进行截取。两者hash值比对。时间复杂度为O(m*n),hash算法参与的字符位数（模式串的长度）、及主串长度正相关 优化：hash算法：按26位进制取和，abc=1+2+3=6 则每一个字符串的hash值是前一个子串的hash值减去子串最小下标值、加上本串的最大下标值 bcd=abc-a+d=6-1+4=9 时间复杂度变为：O（N）,只与主串长度相关，但是hash冲突极端情况下会退化为BF","categories":[{"name":"面试篇","slug":"面试篇","permalink":"https://bowonqin.github.io/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://bowonqin.github.io/tags/%E7%89%9B%E5%AE%A2/"},{"name":"面试","slug":"面试","permalink":"https://bowonqin.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":"qxd"},{"title":"Mybatis(基础)","slug":"mabatis/Mybatis(基础)","date":"2021-12-16T16:00:00.000Z","updated":"2021-12-20T05:19:10.173Z","comments":true,"path":"posts/1111222.html","link":"","permalink":"https://bowonqin.github.io/posts/1111222.html","excerpt":"","text":"Mybatis相关概念ORM(对象关系数据库映射) ORM全称Object/Relation Mapping：表示对象-关系映射的缩写 ORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层SQL操作。ORM框架实现的效果：把对持久化对象的保存、修改、删除等操作，转换为对数据库的操作 Mybatis简介 MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO （Plain Old Java Objects,普通老式Java对 象）为数据库中的记录。 Mybatis历史 原是apache的一个开源项目iBatis, 2010年6月这个项目由apache software foundation 迁移到了google code，随着开发团队转投Google Code旗下，ibatis3.x正式更名为Mybatis ，代码于2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects(DAO) Mybatis优势 Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。 Mybatis基本应用 Mybatis官网地址：http://www.mybatis.org/mybatis-3/ 快速入门开发步骤： 添加Mybatis坐标 创建user数据表 编写User实体类 编写映射文件UserMapper.xml 编写核心文件SqlMapperConfig.xml 编写测试类 环境搭建1）导入MyBatis的坐标和其他相关坐标 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--mybatis坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--单元测试坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2） 创建数据库表 3）编写User实体 public class User { private Integer id; private String username; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + '}'; } } 4） 编写UserMapper映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"user\"&gt; &lt;!-- namespace命名空间，与id组成sql的唯一标识 resultType: 返回值类型 --&gt; &lt;select id=\"findAll\" resultType=\"com.qxd.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 5） 编写Mybatis核心配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 6） 编写测试类 public class MybatisTest { @Test public void test1() throws IOException { // 加载核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); //获得sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得sqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句 List&lt;User&gt; users = sqlSession.selectList(\"user.findAll\"); // 打印结果 for (User : users) { System.out.println(user); } // 释放资源 sqlSession.close(); } } 打印结果为： User{id=1, username='qqq'} User{id=2, username='zhangsan'} User{id=4, username='null'} Mybatis的增删改查操作Mybatis的插入数据操作1） 编写UserMapper映射文件 &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"com.qxd.pojo.User\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 2） 编写测试类 @Test public void test2() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(3); user.setUsername(\"sd\"); sqlSession.insert(\"user.saveUser\",user); sqlSession.commit(); sqlSession.close(); } 3） 插入操作注意问题 插入语句使用insert标签 在映射文件中使用parameterType属性指定要插入的数据类型 Sql语句中使用#{实体属性名}方式引用实体中的属性值 插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); 插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() Mybatis的修改数据操作1） 编写UserMapper映射文件 &lt;!-- 修改--&gt; &lt;mapper&gt; &lt;update id=\"update\" parameterType=\"com.qxd.pojo.User\"&gt; update user set username=#{username} where id = #{id} &lt;/update&gt; &lt;/mapper&gt; 2） 编写测试类 @Test public void test3() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(1); user.setUsername(\"xxx\"); int update = sqlSession.update(\"user.update\", user); System.out.println(update); sqlSession.commit(); sqlSession.close(); } 3） 修改操作注意问题 修改语句使用update标签 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); Mybatis的删除数据操作1） 编写UserMapper映射文件 &lt;mapper&gt; &lt;!-- 删除--&gt; &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 2） 编写测试类 // 删除 public void test4() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int delete = sqlSession.delete(\"user.delete\", 5); System.out.println(delete); sqlSession.commit(); sqlSession.close(); } 3） 删除操作注意问题 删除语句使用delete标签 Sql语句中使用#{任意字符串}方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); Mybatis的映射文件概述 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--映射文件DTD约束头--&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!--mapper为根标签--&gt; &lt;mapper namespace=\"user\"&gt; &lt;!-- namespace命名空间，与id组成sql的唯一标识 resultType: 返回值类型 --&gt; &lt;select id=\"findAll\" resultType=\"com.qxd.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; Mybatis常用映射文件解析1） environments标签 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--当前运行环境--&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据源配置的基本餐宿--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 2） mapper标签 该标签的作用是加载映射的，加载方式有如下几种： &lt;!--使用相对于类路径的资源引用，例如：--&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;!--使用完全限定资源定位符（URL），例如： --&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;!--使用映射器接口实现类的完全限定类名，例如： --&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!--将包内的映射器接口实现全部注册为映射器，例如：--&gt; &lt;mapper name=\"org.mybatis.builder\"/&gt; Mybatis相应API SqlSession工厂构建器SqlSessionFactoryBuilder 常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 SqlSession工厂对象SqlSessionFactory SqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： // 默认为false,需要手动开启事务 SqlSession sqlSession = sqlSessionFactory.openSession(); // 手动提交事务 sqlSession.commit() // -----------------------------------------------------------------------------// // 自动开启事务，无需手动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); SqlSession会话对象 SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有 &lt;T&gt; T selectOne(String statement, Object parameter); &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter); int insert(String statement, Object parameter); int update(String statement, Object parameter); int delete(String statement, Object parameter); 操作事务的方法主要有： void commit() void rollback() Mybatis的Dao层实现传统开发方式 编写UserDao接口 public interface IUserDao { // 查询所有用户 public List&lt;User&gt; findAll() throws IOException; } 编写UserDaoImpl实现 public class UserDaoImpl implements IUserDao { @Override public List&lt;User&gt; findAll() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; users = sqlSession.selectList(\"user.findAll\"); sqlSession.close(); return users; } } 测试传统方式 @Test public void test5() throws IOException { IUserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); for (User user : all) { System.out.println(user); } } 代理开发方式 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范：、 1） Mapper.xml中的namespace与mapper接口的全限类名相同。 2） Mapper接口方法名和Mapper.xm中定义的每个statemen的id相同 3） Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4） Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 测试代理方法 @Test public void test6() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); IUserDao userDao = sqlSession.getMapper(IUserDao.class); List&lt;User&gt; all = userDao.findAll(); for (User user : all) { System.out.println(user); } sqlSession.close(); } Mybatis配置文件深入核心配置文件environments标签&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--当前运行环境--&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据源配置的基本餐宿--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mapper标签该标签的作用是加载映射的，加载方式有如下几种： &lt;!--使用相对于类路径的资源引用，例如：--&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;!--使用完全限定资源定位符（URL），例如： --&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;!--使用映射器接口实现类的完全限定类名，例如： --&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!--将包内的映射器接口实现全部注册为映射器，例如：--&gt; &lt;mapper name=\"org.mybatis.builder\"/&gt; Properties标签实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 加载外部properties --&gt; &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; &lt;!--默认运行环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!--当前事务交由jdbc管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--当前使用mybatis提供的连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; typeAliases标签类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"com.qxd.pojo.User\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 配置typeAliases，为com.lagou.domain.User定义别名为user &lt;typeAliases&gt; &lt;!-- 单独实体起别名 --&gt; &lt;typeAlias type=\"com.qxd.pojo.User\" alias=\"user\"&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; &lt;!-- 插入--&gt; &lt;mapper&gt; &lt;insert id=\"saveUser\" parameterType=\"user\"&gt; insert into user values (#{id},#{username}) &lt;/insert&gt; &lt;/mapper&gt; 批量起别名:该包下所有类的本身的类名：别名不区分大小写 &lt;!-- 给实体类的全限定类名起别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量起别名：该包下所有类的本身的类名：别名不区分大小写--&gt; &lt;package name=\"com.qxd.pojo\"/&gt; &lt;/typeAliases&gt; 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean …… …… 映射配置文件mapper.xml动态sql语句动态 SQL 之 我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 &lt;!-- 多条件组合查询--&gt; &lt;select id=\"findByCondition\" resultType=\"user\" parameterType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"id != null\"&gt; and id = #{id} &lt;/if&gt; &lt;if test=\"username !=null\"&gt; and username = #{username} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 动态 SQL 之 循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 &lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=\"array\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; foreach标签的属性含义如下： 标签用于遍历集合，它的属性： collection: 代表要遍历的集合元素，注意编写时不要写#{}。 open：代表语句的开始部分。 close：代表结束部分。 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 SQL片段抽取 Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 &lt;!-- 抽取mysql片段--&gt; &lt;sql id=\"selectUser\"&gt; select * from User &lt;/sql&gt; &lt;select id=\"findAll\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;/select&gt; Mybatis复杂映射开发一对一查询一对一查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询语句对应的sql语句： select * from orders o,user u where o.uid=u.id; 查询的结果如下： 创建Order和User实体public class Order { private Integer id; private String ordertime; private Double total; //代表当前订单从属于哪一个客户 private User user; get() set() } public class User { private Integer id; private String username; private String password; private String birthday; get() set() } 创建IUserMapper接口public interface IUserMapper { // 查询订单的同时还查询该订单所属的用户 public List&lt;Order&gt; findOrderAndUser(); } 配置IUserMapper.xml&lt;mapper namespace=\"com.qxd.mapper.IUserMapper\"&gt; &lt;!--resultMap:手动配置实体属性和表字段的映射关系 --&gt; &lt;resultMap id=\"orderMap\" type=\"com.qxd.pojo.Order\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"orderTime\" column=\"orderTime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"com.qxd.pojo.User\"&gt; &lt;result property=\"id\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findOrderAndUser\" resultMap=\"orderMap\"&gt; select * from orders o,user u where o.uid=u.id; &lt;/select&gt; &lt;/mapper&gt; 其中，sqlMapperConfig.xml导包的时候可以做如下配置 &lt;mappers&gt; &lt;!--同包同名--&gt; &lt;package name=\"com.qxd.mapper\"/&gt; &lt;/mappers&gt; 其中，使用package标签导包的时候要保证mapper.xml与mapper接口同包同名才能成功。 一对多查询模型一对多查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户。一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询语句对应的sql语句： select *,o.id oid from user u left join orders o on u.id=o.uid; 查询的结果如下： 修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); } public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; } 创建IUserMapper接口public interface IUserMapper { // 查询所有用户拥有的订单 public List&lt;User&gt; findAll(); } 配置IUserMapper.xml&lt;mapper&gt; &lt;resultMap id=\"userMap\" type=\"com.qxd.pojo.User\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!--集合类型+泛型--&gt; &lt;collection property=\"orderList\" ofType=\"com.qxd.pojo.Order\"&gt; &lt;result property=\"id\" column=\"oid\"&gt;&lt;/result&gt; &lt;result property=\"orderTime\" column=\"orderTime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select *,o.id oid from user u left join orders o on u.id=o.uid; &lt;/select&gt; &lt;/mapper&gt; 多对多查询多对多查询模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询语句对应的sql语句： SELECT u.*, r.*, r.id rid FROM USER u LEFT JOIN sys_user_role ur ON u.id = ur.userid LEFT JOIN sys_role r ON ur.roleid = r.id; 查询结果如下 创建Role实体，修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); // 表示用户当前的角色 private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); } public class Role { private Integer id; private String roleName; private String roleDesc; } 添加UserMapper接口方法// 查询所有用户拥有的角色 public List&lt;User&gt; findAllUserAndRole(); 配置IUserMapper.xml&lt;mapper&gt; &lt;resultMap id=\"userRoleMap\" type=\"user\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;collection property=\"roleList\" ofType=\"Role\"&gt; &lt;result property=\"id\" column=\"rid\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"roleDesc\"&gt;&lt;/result&gt; &lt;result property=\"roleName\" column=\"roleName\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAllUserAndRole\" resultMap=\"userRoleMap\"&gt; SELECT u.*, r.*, r.id rid FROM USER u LEFT JOIN sys_user_role ur ON u.id = ur.userid LEFT JOIN sys_role r ON ur.roleid = r.id; &lt;/select&gt; &lt;/mapper&gt; 知识小结一对一配置： 使用做配置 一对多配置： 使用+做配置 多对多配置： 使用+做配置 Mybatis注解开发MyBatis常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 Mybatis增删改查我们完成简单的user表的增删改查的操作 private IUserMapper userMapper; @BeforeEach public void before() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(\"sqlMapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(IUserMapper.class); } @Test public void addUserTest() throws IOException { User user = new User(); user.setId(6); user.setUsername(\"qqq\"); user.setBirthday(\"2021-1-1\"); user.setPassword(\"123321\"); userMapper.addUser(user); } @Test public void selectUserTest(){ List&lt;User&gt; users = userMapper.selectUsers(); for (User user : users) { System.out.println(user); } } @Test public void udpateUserTest(){ User user = new User(); user.setId(6); user.setUsername(\"xxx\"); user.setBirthday(\"2021-11-1\"); user.setPassword(\"1233221\"); userMapper.updateUser(user); } @Test public void deleteUserTest(){ userMapper.delete(6); } MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 一对一查询一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 一对一查询的语句select * from orders; select * from user where id=查询出订单的uid; 创建Order和User实体public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; get set toString() } public class User { private Integer id; private String username; private String password; private String birthday; get set toString() } 创建OrderMapper接口public interface IOrderMapper { public List&lt;Order&gt;findAll(); } 使用注解配置Mapperpublic interface IOrderMapper { @Select(\"select * from orders\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"orderTime\",column = \"ordertime\"), @Result(property = \"total\",column = \"total\"), @Result(property = \"user\",column = \"uid\",javaType = User.class,one = @One(select = \"com.qxd.mapper.IUserMapper.findById\")), }) public List&lt;Order&gt;findAll(); } public interface IUserMapper{ @Select(\"select * from user where id=#{id}\") public User findById(Integer id); } 测试结果 @Test public void testSelectOrderAndUser() { List&lt;Order&gt; all = orderMapper.findAll(); for (Order order : all) { System.out.println(order); } } // 打印结果 Order{id=1, orderTime=2019-12-12, total=3000.0, user=User{id=1, username='lucy', password='123', birthday='2019-12-12} Order{id=2, orderTime=2019-12-12, total=4000.0, user=User{id=1, username='lucy', password='123', birthday='2019-12-12} Order{id=3, orderTime=2019-12-12, total=5000.0, user=User{id=2, username='tom', password='123', birthday='2019-12-12} 一对多查询一对多查询模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 一对多查询的语句对应的sql语句： select * from user; select * from orders where uid=查询出用户的id; 修改Order和User实体public class Order { private Integer id; private String orderTime; private Double total; //代表当前订单从属于哪一个客户 private User user; get set toString() } public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); get set toString() } 创建UserMapper接口public interface IUserMapper { public List&lt;User&gt; findOrderAndUserByAnnotation(); } 使用注解配置Mapperpublic interface IUserMapper { // 查询订单的同时还查询该订单所属的用户 @Select(\"select * from user\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"orderList\",column = \"id\",javaType = List.class,many = @Many(select = \"com.qxd.mapper.IOrderMapper.findByUid\")), }) public List&lt;User&gt; findOrderAndUserByAnnotation(); } public interface IOrderMapper { @Select(\"select * from orders where uid=#{uid}\") public Order findByUid(Integer uid); } 测试结果 @Test public void testSelectUserAndOrder(){ List&lt;User&gt; orderAndUserByAnnotation = userMapper.findOrderAndUserByAnnotation(); for (User user : orderAndUserByAnnotation) { System.out.println(user); } } // 打印结果 User{id=1, username='lucy', password='123', birthday='2019-12-12', orderList=[Order{id=1, orderTime='2019-12-12', total=3000.0}, Order{id=2, orderTime='2019-12-12', total=4000.0}]} User{id=2, username='tom', password='123', birthday='2019-12-12', orderList=[Order{id=3, orderTime='2019-12-12', total=5000.0}]} User{id=3, username='jack', password='123', birthday='2017-1-1', orderList=[]} User{id=5, username='qqq', password='123321', birthday='2021-1-1', orderList=[]} 多对多查询多对多查询模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 多对多查询语句select * from user; select * from role r, sys_user_role ur where r.id=ur.roleid and ur.userid=用户的id 创建Role实体，修改User实体public class User { private Integer id; private String username; private String password; private String birthday; // 表示用户关联的订单 // private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); // 表示用户当前的角色 private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); get set toString } public class Role { private Integer id; private String roleName; private String roleDesc; get set toString } 添加UserMapper接口方法public interface IUserMapper { public List&lt;User&gt; findOrderAndUserByAnnotation(); } 使用注解配置Mapperpublic interface IUserMapper{ @Select(\"select * from user\") @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"roleList\",column = \"id\",javaType = List.class,many = @Many(select = \"com.qxd.mapper.IRoleMapper.findRoleByUid\")), }) public List&lt;User&gt; findUserAndRoleByAnnotation(); } public interface IRoleMapper{ @Select(\"select * from sys_role r, sys_user_role ur where r.id=ur.roleid and ur.userid=#{uid}\") public Role findRoleByUid(Integer uid); } 测试结果 @Test public void testUserAndRole(){ List&lt;User&gt; userAndRoleByAnnotation = userMapper.findUserAndRoleByAnnotation(); for (User user : userAndRoleByAnnotation) { System.out.println(user); } } // 打印结果 User{id=1, username='lucy', password='123', birthday='2019-12-12', roleList=[Role{id=1, roleName='CTO', roleDesc='CTO'}, Role{id=2, roleName='CEO', roleDesc='CEO'}]} User{id=2, username='tom', password='123', birthday='2019-12-12', roleList=[Role{id=1, roleName='CTO', roleDesc='CTO'}, Role{id=2, roleName='CEO', roleDesc='CEO'}]} User{id=3, username='jack', password='123', birthday='2017-1-1', roleList=[]} User{id=5, username='qqq', password='123321', birthday='2021-1-1', roleList=[]}","categories":[{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"}],"author":"qxd"},{"title":"Springboot+SpringSecurity+Vue后台管理系统","slug":"实战项目/Springboot+Vue后台管理系统(Vue)","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-20T05:24:44.364Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://bowonqin.github.io/posts/2.html","excerpt":"","text":"安装Vue环境，新建Vue项目 查看nodejs和npm版本信息 安装vue环境 # 安装淘宝npm npm install -g cnpm --registry=https://registry.npm.taobao.org # 安装vue-cli依赖包 cnpm install -g vue-cli # 打开vue可视化管理工具vue ui vue ui 是一个可视化管理工具，可以运行项目、打包项目、检查等操作 按步骤下一步即可 安装Element-uicnpm install element-ui --save 安装成功后，打开项目src中的main.js，引入element-ui的依赖 import Element from \"element-ui\" import \"element-ui/lib/theme-chalk/index.css\" Vue.use(Element); 安装axios、qs、mockjs axios: 一个基于promise的HTTP库，类似ajax 安装： cnpm install axios --save 引入依赖 import axios from 'axios' Vue.prototype.$axios = axios qs: 查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，也可以将一个查询字符串解析成一个object 安装： cnpm install qs --save mockjs: 随机数据工具库 安装： cnpm install axios --save-dev 页面路由 传统项目开发，后端通过链接达到控制器再到页面渲染 前后端分离：先访问页面，然后异步加载数据渲染。路由管理的组件为Router Router: 建立起url和页面之间的映射关系 import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home.vue' Vue.use(VueRouter) const routes = [{ path: '/', name: 'Home', component: Home }, { path: '/login/', name: 'Login', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =&gt; import( /* webpackChunkName: \"about\" */ '../views/Login.vue') } ] const router = new VueRouter({ routes, mode: 'history' //去除#号 }) export default router 通过访问 http://localhost:8081/ 可以访问到Home.vue中的内容，这种先import的模式是及急加载模式。 通过访问 http://localhost:8081/login 可以访问到Login.vue中的内容，这种用到组件再import模式是懒加载的模式。 登录页面的开发开发流程： 浏览器打开登录页面 动态加载登录验证码，前后端分离项目不用session进行交互，禁用session。在后端生成验证码同时生成随机码，随机码作为key，验证码作为value存放在redis中，然后把随机码和验证码的Base64字符串发送到前端 前端提交用户名、密码、验证码和随机码 后台验证验证码是否匹配以及密码是否正确 mock.js的设计 const Mock = require(\"mockjs\"); const Random = Mock.Random let Result = { code: 200, msg: '操作成功', data: null } Mock.mock(\"/captcha\", 'get', () =&gt; { Result.data ={ token: Random.string(32), captchaImg: Random.dataImage('100x40','p7n5w') } return Result }) Mock.mock(\"/login\",'post',()=&gt;{ // 无法在header中传入数据 }) 模拟后台发送随机码和Base64编码的验证码 login.vue页面的设计 &lt;template&gt; &lt;el-row type=\"flex\" class=\"row-bg\" justify=\"center\"&gt; &lt;el-col :xl=\"6\" :lg=\"7\"&gt; &lt;h2&gt;欢迎来到VueAdmin管理系统&lt;/h2&gt; &lt;el-image :src=\"require('@/assets/logo.png')\" style=\"height: 180px; width: 180px\" &gt;&lt;/el-image&gt; &lt;/el-col&gt; &lt;!-- 分割线 --&gt; &lt;el-col :span=\"1\"&gt; &lt;el-divider direction=\"vertical\"&gt;&lt;/el-divider&gt; &lt;/el-col&gt; &lt;el-col :xl=\"6\" :lg=\"7\"&gt; &lt;el-form :model=\"LoginForm\" :rules=\"rules\" ref=\"LoginForm\" label-width=\"100px\" class=\"demo-LoginForm\" &gt; &lt;el-form-item label=\"用户名\" prop=\"username\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.username\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"password\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.password\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"验证码\" prop=\"code\" style=\"width: 380px\"&gt; &lt;el-input v-model=\"LoginForm.code\" style=\"width: 172px; float: left\" maxlength=\"5\" &gt;&lt;/el-input&gt; &lt;el-image :src=\"captchaImg\" class=\"captchaImg\" &gt;&lt;/el-image&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" @click=\"submitForm('LoginForm')\" &gt;立即创建&lt;/el-button &gt; &lt;el-button @click=\"resetForm('LoginForm')\"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { LoginForm: { username: \"\", password: \"\", code: \"\", token: \"\", }, rules: { username: [ { required: true, message: \"请输入用户名\", trigger: \"blur\" }, ], password: [{ required: true, message: \"请输入密码\", trigger: \"blur\" }], code: [ { required: true, message: \"请输入验证码\", trigger: \"blur\" }, { min: 5, max: 5, message: \"长度为5个字符\", trigger: \"blur\" }, ], }, captchaImg: null, }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { this.$axios.post(\"/login\", this.LoginForm).then((res) =&gt; { const jwt = res.headers['authorization'] this.$store.commit('SET_TOKEN', jwt) this.$router.push(\"/index\") }); } else { console.log(\"error submit!!\"); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); }, getCaptcha() { this.$axios.get(\"/captcha\").then((res) =&gt; { console.log(\"/captcha\"); console.log(res); this.LoginForm.token = res.data.data.token; this.captchaImg = res.data.data.captchaImg; }); }, }, created() { this.getCaptcha(); }, }; &lt;/script&gt; &lt;style scoped&gt; .el-row { background-color: #fafafa; height: 100vh; display: flex; align-items: center; text-align: center; justify-content: center; } .el-divider { height: 200px; } .captchaImg { float: left; margin-left: 8px; border-radius: 4px; } &lt;/style&gt;","categories":[{"name":"实战项目篇","slug":"实战项目篇","permalink":"https://bowonqin.github.io/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"实战项目","slug":"实战项目","permalink":"https://bowonqin.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"},{"name":"Vue","slug":"Vue","permalink":"https://bowonqin.github.io/tags/Vue/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://bowonqin.github.io/tags/SpringSecurity/"}],"author":"qxd"}],"categories":[{"name":"Mysql篇","slug":"Mysql篇","permalink":"https://bowonqin.github.io/categories/Mysql%E7%AF%87/"},{"name":"SSM篇","slug":"SSM篇","permalink":"https://bowonqin.github.io/categories/SSM%E7%AF%87/"},{"name":"面试篇","slug":"面试篇","permalink":"https://bowonqin.github.io/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"name":"实战项目篇","slug":"实战项目篇","permalink":"https://bowonqin.github.io/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AF%87/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://bowonqin.github.io/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://bowonqin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://bowonqin.github.io/tags/Mybatis/"},{"name":"牛客","slug":"牛客","permalink":"https://bowonqin.github.io/tags/%E7%89%9B%E5%AE%A2/"},{"name":"面试","slug":"面试","permalink":"https://bowonqin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"实战项目","slug":"实战项目","permalink":"https://bowonqin.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"},{"name":"Springboot","slug":"Springboot","permalink":"https://bowonqin.github.io/tags/Springboot/"},{"name":"Vue","slug":"Vue","permalink":"https://bowonqin.github.io/tags/Vue/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://bowonqin.github.io/tags/SpringSecurity/"}]}